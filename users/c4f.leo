<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<?xml-stylesheet ekr_test ?>
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20151212173315.1"><vh>@settings</vh>
<v t="leo.20151212173315.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20151212173315.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="amd.20160306101815.1" a="E"><vh>網站規劃</vh>
<v t="amd.20160306101823.1"><vh>code4future.org</vh></v>
<v t="amd.20160306182104.1"><vh>內容分類</vh></v>
</v>
<v t="amd.20160309162721.1" a="E"><vh>Wordpress 端</vh>
<v t="amd.20160309162721.2"><vh>@button new to wp (pelican)</vh>
<v t="amd.20160309162721.3"><vh>md 檔案的格式</vh></v>
<v t="amd.20160309162721.4"><vh>將 md 節點內容送到 Wordpress 方法</vh></v>
</v>
<v t="amd.20160309162721.5"><vh>@button edit to wp (pelican)</vh></v>
<v t="amd.20160309175129.1"><vh>@button get from wp (pelican)</vh>
<v t="amd.20160309175129.2"><vh>程式設計考量</vh></v>
</v>
<v t="amd.20160309162721.8"><vh>Leo Editor 程式開發</vh></v>
</v>
<v t="amd.20160320145431.1"><vh>有關 reeborg</vh></v>
<v t="amd.20160106095324.1" a="E"><vh>@path ./../</vh>
<v t="leo.20151213173811.1" a="E"><vh>假如要送到 gh-pages 分支, 使用下列按鈕</vh>
<v t="leo.20151212173658.1"><vh>@button gh-pages pelican</vh></v>
</v>
<v t="leo.20151213173830.1" a="E"><vh>假如要在近端檢視, 使用下列按鈕</vh>
<v t="leo.20151213085727.1"><vh>@button local pelican</vh></v>
</v>
<v t="amd.20160117010542.1"><vh>@button git rm -rf blog</vh></v>
<v t="amd.20151215180106.1"><vh>設定與開發</vh>
<v t="amd.20151216151325.1"><vh>@edit index.html</vh></v>
<v t="amd.20151216152209.1"><vh>@edit README.md</vh></v>
<v t="leo.20151213230723.1" a="E"><vh>Pelican 設定</vh>
<v t="leo.20151213230957.1"><vh>文章 Date 設定</vh></v>
<v t="leo.20151213230729.1"><vh>使用 summary plugin</vh></v>
</v>
<v t="amd.20151215170117.1"><vh>以下 pelicanconf.py 為近端與遠端的共同設定</vh></v>
<v t="leo.20151212173725.1"><vh>@edit pelicanconf.py</vh></v>
<v t="amd.20151215170142.1"><vh>以下 publishconf.py 為遠端所使用的設定</vh></v>
<v t="leo.20151212173803.1"><vh>@edit publishconf.py</vh></v>
<v t="amd.20151215170221.1"><vh>以下 local_publishconf.py 為近端所使用的設定</vh></v>
<v t="leo.20151213085752.1"><vh>@edit local_publishconf.py</vh></v>
<v t="amd.20151215121740.1"><vh>@path theme</vh>
<v t="amd.20151215121758.1" a="E"><vh>@path pelican-bootstrap3</vh>
<v t="amd.20151215121816.1" a="E"><vh>@path templates</vh>
<v t="amd.20151215121827.1"><vh>@edit base.html</vh></v>
<v t="amd.20151215121849.1"><vh>@edit search.html</vh></v>
<v t="amd.20151215152634.1"><vh>@edit tags.html</vh></v>
</v>
<v t="amd.20151216181314.1" a="E"><vh>@path static</vh>
<v t="amd.20151216181314.2" a="E"><vh>@path css</vh>
<v t="amd.20151216181314.3" a="E"><vh>@path pygments</vh>
<v t="amd.20151216181314.4"><vh>@edit fruity.css</vh></v>
</v>
</v>
</v>
</v>
<v t="amd.20151215154950.1" a="E"><vh>@path pelican-bootstrap3_local</vh>
<v t="amd.20151215154950.2" a="E"><vh>@path templates</vh>
<v t="amd.20151215154950.3"><vh>@edit base.html</vh></v>
<v t="amd.20151215154950.4"><vh>@edit search.html</vh></v>
<v t="amd.20151215162536.1" a="E"><vh>@path includes</vh>
<v t="amd.20151215162510.1"><vh>@edit sidebar.html</vh></v>
</v>
<v t="amd.20151215154950.5"><vh>@edit tags.html</vh></v>
</v>
<v t="amd.20151216173334.1" a="E"><vh>@path static</vh>
<v t="amd.20151216173344.1" a="E"><vh>@path css</vh>
<v t="amd.20151216173352.1" a="E"><vh>@path pygments</vh>
<v t="amd.20151216173409.1"><vh>@edit fruity.css</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="amd.20151215170326.1"><vh>以下在修改或查驗 plugin 目錄下的檔案</vh></v>
<v t="amd.20151215154225.1" a="E"><vh>@path plugin</vh>
<v t="amd.20151215154238.1" a="E"><vh>@path tipue_search</vh>
<v t="amd.20151215154248.1"><vh>@edit tipue_search.py</vh></v>
</v>
</v>
</v>
<v t="amd.20160324163947.1"><vh>研究專案</vh>
<v t="amd.20160324163954.1" a="E"><vh>Raspberry pi 3 應用</vh>
<v t="amd.20160324172443.1"><vh>從 Windows 連接</vh></v>
<v t="amd.20160324172457.1"><vh>從 Ubuntu 連接</vh></v>
<v t="amd.20160324171436.1"><vh>Mathematica</vh></v>
<v t="amd.20160324221453.1"><vh>Junyper</vh></v>
<v t="amd.20160324173857.1"><vh>LaTeX</vh></v>
<v t="amd.20160324174604.1" a="E"><vh>BYOD</vh>
<v t="amd.20160324201508.1"><vh>兒童電腦價格</vh></v>
</v>
</v>
</v>
</v>
<v t="amd.20160410201430.1"><vh>blockdiag</vh>
<v t="amd.20160410201430.2"><vh>@button blockdiag</vh></v>
<v t="amd.20160410201430.3"><vh>blockdiag</vh></v>
<v t="amd.20160410201438.1"><vh>cf4_block</vh></v>
<v t="amd.20160410201430.4"><vh>@button nwdiag</vh></v>
<v t="amd.20160410201430.5"><vh>nwdiag</vh></v>
</v>
<v t="amd.20151215170350.1"><vh>以下為 content 目錄中的 md 檔案</vh></v>
<v t="amd.20160106093610.1"><vh>協同網誌編寫規範</vh></v>
<v t="amd.20151216001126.1"><vh>md 檔案範例</vh></v>
<v t="amd.20151215170031.1" a="E"><vh>@path ./../content</vh>
<v t="amd.20160106093454.1" a="E"><vh>網誌 md 檔案</vh>
<v t="amd.20160213095053.1" a="E"><vh>201602</vh>
<v t="amd.20160224170554.1"><vh>@clean c4f_20160225.md</vh>
<v t="amd.20160309174033.1"><vh>10</vh></v>
</v>
<v t="amd.20160224171626.1"><vh>@clean c4f_20160225-1.md</vh>
<v t="amd.20160319074114.1"><vh>18</vh></v>
</v>
</v>
<v t="amd.20160306214231.1" a="E"><vh>201603</vh>
<v t="amd.20160306214240.1"><vh>@clean c4f_20160306-1.md</vh>
<v t="amd.20160319074122.1"><vh>20</vh></v>
</v>
<v t="amd.20160306214335.1"><vh>@clean c4f_20160306-2.md</vh>
<v t="amd.20160319074059.1"><vh>16</vh></v>
</v>
<v t="amd.20160319232117.1"><vh>@clean c4f_20160319-2.md</vh>
<v t="amd.20160712092639.1"><vh>58</vh></v>
</v>
<v t="amd.20160319123316.1"><vh>下一則只有標題與 id 的文章, 只送到 WP</vh></v>
<v t="amd.20160309191406.1"><vh>掌握未來, 速學編程</vh>
<v t="amd.20160309191408.1"><vh>1</vh></v>
</v>
<v t="amd.20160319123605.1"><vh>@clean c4f_20160319.md</vh>
<v t="amd.20160319132434.1"><vh>24</vh></v>
</v>
<v t="amd.20160319222458.1"><vh>@clean c4f_20160319-1.md</vh>
<v t="amd.20160319230246.1"><vh>27</vh></v>
</v>
<v t="amd.20160320001047.1"><vh>@clean c4f_20160320.md</vh>
<v t="amd.20160712092645.1"><vh>60</vh></v>
</v>
<v t="amd.20160320182523.1"><vh>@clean c4f_20160320-1.md</vh>
<v t="amd.20160320184332.1"><vh>34</vh></v>
</v>
<v t="amd.20160324193327.1"><vh>@clean c4f_20160324.md</vh>
<v t="amd.20160712092649.1"><vh>62</vh></v>
</v>
<v t="amd.20160330005047.1"><vh>@clean c4f_20160330.md</vh>
<v t="amd.20160712092655.1"><vh>64</vh></v>
</v>
<v t="amd.20160712094256.1"><vh>@clean c4f_20160712.md</vh>
<v t="amd.20160712231633.1"><vh>67</vh></v>
</v>
<v t="amd.20160715215651.1"><vh>@clean c4f_20160715.md</vh>
<v t="amd.20160716001133.1"><vh>85</vh></v>
</v>
<v t="amd.20160717151500.1"><vh>@clean c4f_20160717.md</vh>
<v t="amd.20160717163525.1"><vh>92</vh></v>
</v>
<v t="amd.20160717183001.1"><vh>我們如何建立這個網站 (三)</vh>
<v t="amd.20160721205749.1"><vh>97</vh></v>
</v>
<v t="amd.20160718233536.1"><vh>@clean c4f_20160718.md</vh>
<v t="amd.20160721205754.1"><vh>109</vh></v>
</v>
<v t="amd.20160721203641.1"><vh>@clean c4f_20160721.md</vh>
<v t="amd.20160721205758.1"><vh>111</vh></v>
</v>
<v t="amd.20160724161400.1"><vh>@clean c4f_20160724.md</vh></v>
</v>
</v>
</v>
<v t="amd.20160106094754.1" a="E"><vh>@path ./../content/pages</vh>
<v t="amd.20160106094829.1" a="E"><vh>code4future pages 文章</vh>
<v t="amd.20160106094844.1"><vh>@edit cf4_pages_1.md</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="amd.20151215121740.1"></t>
<t tx="amd.20151215121758.1"></t>
<t tx="amd.20151215121816.1"></t>
<t tx="amd.20151215154225.1"></t>
<t tx="amd.20151215154238.1"></t>
<t tx="amd.20151215154950.1"></t>
<t tx="amd.20151215154950.2"></t>
<t tx="amd.20151215162536.1"></t>
<t tx="amd.20151215170031.1"></t>
<t tx="amd.20151215170117.1"></t>
<t tx="amd.20151215170142.1"></t>
<t tx="amd.20151215170221.1"></t>
<t tx="amd.20151215170326.1"></t>
<t tx="amd.20151215170350.1"></t>
<t tx="amd.20151215180106.1"></t>
<t tx="amd.20151216001126.1">@language md
Title: 文章標題
Category: 類別
Tags: 標籤
Author: code4future

這裡放入文章摘要

&lt;!-- PELICAN_END_SUMMARY --&gt;

這裡為文章主要內容</t>
<t tx="amd.20151216173334.1"></t>
<t tx="amd.20151216173344.1"></t>
<t tx="amd.20151216173352.1"></t>
<t tx="amd.20151216181314.1"></t>
<t tx="amd.20151216181314.2"></t>
<t tx="amd.20151216181314.3"></t>
<t tx="amd.20160106093454.1"></t>
<t tx="amd.20160106093610.1">協同成員的 .leo 檔案

    每一位協同者, 各自可以在 users 目錄下擁有一個 .leo 檔案, 用來維護各自位於 content 目錄下的 .md 檔案,
    
    例如: user code4future 的 .leo 檔案位於 users/c4f.leo

協同成員的 .md 檔案命名

    由於各成員所編寫的 .md 檔案都位於 content 目錄下, 因此必須在各負責的 .md 檔案名稱冠上用戶名稱,
    
    例如: 由 code4future 負責編寫的 .md 檔案, 特別命名為 c4f_20160106.md, 若一天有兩篇以上文章, 則取 c4f_20160106-1.md
    
    當使用者要利用 pelican 在近端轉換網誌時, 必須使用 local-pelican 按鈕, 若要送到 github pages 網站, 則必須透過 gh-pages-pelican 按鈕轉檔.

pages 文章

    寫在 content/pages 目錄中的 .md 檔案, 將會被轉為網誌 pages 內容

</t>
<t tx="amd.20160106094754.1"></t>
<t tx="amd.20160106094829.1"></t>
<t tx="amd.20160106095324.1"></t>
<t tx="amd.20160117010542.1">@language python
import os
os.system("git rm -rf blog")
g.es("git rm -rf blog 執行完畢")</t>
<t tx="amd.20160213095053.1"></t>
<t tx="amd.20160224170554.1">@language md
Title: 為什麼大家都要你學電腦?
Category: K-12
Tags: Reeborg 機器人
Author: code4future
@others
學電腦?學習寫程式?然後呢?

&lt;!-- PELICAN_END_SUMMARY --&gt;

學電腦是一個非常廣的題目, 因為電腦原來的意思是計算器, 現在的計算器到處都是, 從冷氣的溫度控制到手機, 都是不同等級的電腦. 所以嚴格來說, 與電腦有關的學習是學不完的, 當全世界許多現代人都已經離不開電腦的時候, 所謂的學電腦, 應該是指:

1. 了解電腦的基本軟體與硬體運作原理
2. 了解電腦的基本操作方法
3. 了解如何操控電腦, 並且用電腦來協助解決問題

接著來回答, 為什麼大家都叫你學電腦?最主要的原因就是, 現代人無論從事那一個行業, 都需要依賴電腦來解決問題, 所以假如學生能夠從小就知道什麼叫作數位運算, 有那些特性, 與現實世界的運作有那些關聯, 學習如何利用電腦來增加工作效率, 那麼才能在父母與老師的協助下, 真正發揮電腦的功用.

這一篇文章的類別是: K-12, K 指的是幼稚園的學生, 也就是五歲到六歲的孩童, 我們當然不是寫文章給幼稚園的小朋友看的, 但這裡指的 12, 就是 12 年國教的學生, 從小學一年級開始到高中畢業, 總共 12 年, 假如你是國小高年級以上的學生, 已經可以利用 Code4future 網站上的資料, 進行自學, 但是我們並不鼓勵你們這樣做, 因為你們還沒有成年, 也就是還沒有滿十八歲, 根據我們的經驗, 未成年的學生是不允許獨自上網的, 希望能夠在家長或老師的指導下, 下載 Code4future 上的教案資料, 可以在沒有外部網路 (也稱為廣域網路) 的單機或內部網路上執行.

我們特別鼓勵過去以為學電腦就是玩遊戲的國小高年級學生, 能夠在家長與老師的協助下, 儘早學習利用電腦來解決問題的訣竅, 讓你可以更加了解學習的樂趣, 並且有效率地學習其他學科, 以便空出更多時間發展個人技藝或專長.

這裡要介紹的電腦程式學習課程之一是 Reeborg 機器人: &lt;http://reeborg.ca/world.html&gt;, 假如你用瀏覽器打開這個頁面之後, 完全看不懂其中的英文字與說明段落, 我們希望你不要用翻譯軟體來看這些資料, 因為我們要告訴你, 想學好電腦, 英文能力是必備條件, 而且基本的數學能力也是有效運用電腦的另一個必要條件, 所以不要以為只要學會使用電腦, 就可以丟開其他課本, 正確的學習電腦觀念是:

1. 未成年學生不要獨自上網, 因為網路上沒有用的東西比有用的資料, 多了許多, 你要在老師與家長的安排之下才能使用電腦與網路.
2. 電腦與數學及英文, 或者其他各種學科, 都有很密切的關聯, 學習電腦是要讓你的學習更有效率, 及早掌握現代人協同合作的方式.
3. 學習電腦的主要目的在解決問題, 這些問題當然包括用有效率的方式來提供使用者遊戲或運動或玩樂.

最後, 我們再次提醒你, 為什麼大家都叫你學電腦? 因為我們希望你未來能夠快速融入國際社會, 利用電腦解決各種問題, 做一個有用的青年, 造福社會!

</t>
<t tx="amd.20160224171626.1">@language md
Title: 家長如何制定網路使用政策
Category: 家長
Tags: 網路操作
Author: code4future
@others
無論您從事那一個行業, 週遭一定充滿了各種網路與大小電腦的應用, 從大樓的門禁開始, 電梯、飲水機, 更不用提許多人辦公地點幾乎都各有一台桌上型或筆記型的個人電腦, 透過無線或有線網路與各種資訊系統或網站相連, 未來, 有關網路與電腦的各種應用, 更會密切涉入現代人的生活.

&lt;!-- PELICAN_END_SUMMARY --&gt;

因此, 身為家長的您, 除了必須體認到未來的現代國民已經離不開網路與電腦之外, 必須了解目前全世界有關網路內容分級, 都是採取軟性的自我管制模式, 所以各位家長必須自己在家裡, 嚴格制定未成年兒童的網路使用政策.

我們的認知:

未成年兒童, 不應該獨自使用公共網路, 更不應該在沒有家長的管制下, 上網交友.

根據 Facebook 的規定 &lt;a href="https://www.facebook.com/help/210644045634222"&gt;13 歲以上&lt;/a&gt; 才能建立帳號, 也就是 grade 7, 國中之後的年輕人才能夠使用臉書, 所以身為家長, 必須限制國小學童在家自由使用網路與電腦 (包括手機) 的權力, 假如配合學校功課的要求,  13 歲之前的孩童, 最好是在家長的陪同下使用廣域網路與電腦.
</t>
<t tx="amd.20160306101815.1"></t>
<t tx="amd.20160306101823.1">code4future.org 會 redirect 到 www.code4future.org, 然後再 redirect 到 www.code4future.org/blog/

然後其中再根據服務對象:

未成年學員 - 想透過編程學習, 克服未來挑戰的 K-12
家長 - K-12 學員的父母或其他家庭長輩
教師 - 有意推廣未成年學員編程教育的成年人
社會人士 - 想透過編程學習, 克服未來職場挑戰的成年人

建立相關教案內容

</t>
<t tx="amd.20160306182104.1">Green logo - 綠色 (成長中) - 未成年學員
Red logo - 紅色 (隨時保持紅色警戒) - 家長
Blue logo - 藍色 (指引美麗藍天所在的團隊) -  教師
Yellow logo - 黃色 (以黃皮膚的華人為主要對象) - 社會人士

Black logo - 黑色 - 通用內容</t>
<t tx="amd.20160306214231.1"></t>
<t tx="amd.20160306214240.1">@language md
Title: 有關學童電腦教學
Category: 教師
Tags: 導引
Author: code4future
@others
數位運算裝置融入各種教學的趨勢已經不可避免, 身為幼稚園到國小的教師, 可以利用現有的優秀教材來推廣學童電腦教學.

&lt;!-- PELICAN_END_SUMMARY --&gt;

這裡先介紹來自台灣, 兩個很棒的線上教材:

1. 均一教育平台: &lt;a href="http://www.junyiacademy.org/"&gt;http://www.junyiacademy.org/&lt;/a&gt;
2. 橘子蘋果程式設計學苑: &lt;a href="https://orangeapple.co/"&gt;https://orangeapple.co/&lt;/a&gt;

均一平台上的電腦課程:

Scratch: &lt;a href="http://www.junyiacademy.org/root/isc"&gt;http://www.junyiacademy.org/root/isc&lt;/a&gt;

Javascript: &lt;a href="http://www.junyiacademy.org/root/ijs"&gt;http://www.junyiacademy.org/root/ijs&lt;/a&gt;

一小時玩程式: &lt;a href="http://www.junyiacademy.org/computer-science-a/ihc"&gt;http://www.junyiacademy.org/computer-science-a/ihc&lt;/a&gt;

數學式與 LaTeX: &lt;a href="http://www.junyiacademy.org/computer-science-a/i5t"&gt;http://www.junyiacademy.org/computer-science-a/i5t&lt;/a&gt;

橘子蘋果開放教材: &lt;a href="https://orangeapple.co/csr/open-material"&gt;https://orangeapple.co/csr/open-material&lt;/a&gt;

最後則介紹來自美國哈佛大學的 Scratch 開放教材: &lt;a href="http://scratched.gse.harvard.edu/guide/"&gt;http://scratched.gse.harvard.edu/guide/&lt;/a&gt;
</t>
<t tx="amd.20160306214335.1">@language md
Title: 有關社會人士學習電腦
Category: 社會人士
Tags: 電腦基本功能
Author: code4future
@others
社會人士學習電腦的課題很廣, 我們只能提供較為基本的電腦使用功能與觀念的導引, 例如, 有關 Windows 與 Ubuntu 操作系統的取捨, 如何運用網路與網站來提升工作效率等.

&lt;!-- PELICAN_END_SUMMARY --&gt;

Code4Future 將與社會人士學習電腦的主題劃分為:

1. 電腦基本軟硬體層次, 桌上型、筆記型與卡片型電腦的取捨, Windows 或 Ubuntu 操作系統?
2. 基本的本地端網路協定、設定與應用
3. 區域網路上的全球資訊網伺服器與雲端全球資訊網伺服器的應用

全球資訊網上, 免費學習電腦編程的網站:

CodeCademy：

&lt;a href="https://www.codecademy.com/"&gt;https://www.codecademy.com/&lt;/a&gt;

FreeCodeCamp:

&lt;a href="https://www.freecodecamp.com/"&gt;https://www.freecodecamp.com/&lt;/a&gt;

Udemy:

&lt;a href="https://www.udemy.com/"&gt;https://www.udemy.com/&lt;/a&gt;

Khanacademy:

&lt;a href="https://www.khanacademy.org/computing/computer-programming"&gt;https://www.khanacademy.org/computing/computer-programming&lt;/a&gt;</t>
<t tx="amd.20160309162721.1"></t>
<t tx="amd.20160309162721.2">@language python
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
    
os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/home/amd/Desktop/www-code4future.txt"
wordpress = "www.code4future.org"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
# 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}
 
post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published)
# 利用最後的 child 節點來儲存 post_id
to_save_post_id = p.insertAsLastChild()   
# 改為內文為空的節點, id 直接標在 head 標題 
to_save_post_id.b = ""
to_save_post_id.h = post_id
# 因為新增節點, commander 必須 redraw
c.redraw() 

g.es("post_id 為", post_id)
g.es("已經送出資料!")

'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''</t>
<t tx="amd.20160309162721.3">第1行 

    Title: yen - Github Pages 網頁資料更新問題
    
第2行

    Category: Misc
    
第3行

    Tags: Github Pages
    
第4行

    Author: yen

&lt;!-- PELICAN_END_SUMMARY --&gt; 之前為 文章摘要

之後為文章內容, 但是

~~~python 必須換為 [code lang="python"]
~~~ 則換為 [/code]

然後再看看 &lt;a href="http://project.mde.tw"&gt;http://project.mde.tw&lt;/a&gt; 是否要直接採用 html anchor 或將

Pelican 的 &lt;http://project.mde.tw&gt; 轉為 html anchor 格式

此外, 將 .md 檔案的內容解讀後, 送到對應的 Wordpress 網站後, 將回傳在 .md 檔案的子節點, 加入一個"文章 id "的節點, 內文為該文章在 Wordpress 的 id 號碼

但是從 Pelican md 文章內容解讀後送到 Wordpress, 只支援 new 與 edit, 從 Wordpress 取回文章內容的流程還要再思考一下
</t>
<t tx="amd.20160309162721.4">滑鼠停在 .md 文章的對應節點, 然後按下 new-wp-pelican 按鈕,
完成後該 .md 節點下屬會傳回文章 id 節點, 標示在 Wordpress 的對應文章 id</t>
<t tx="amd.20160309162721.5">@language python
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &lt;!-more-&gt;
    content = content.replace('&lt;!-- PELICAN_END_SUMMARY --&gt;', '&lt;!--more--&gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
    
os.environ['TZ'] = 'Asia/Taipei'
 
#################################
filepath = "/home/amd/Desktop/www-code4future.txt"
wordpress = "www.code4future.org"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

# 設法取得原 post 的 id
origin_post = p.getLastChild()
# 直接從標題取得 post 的 id 號碼
post_id = origin_post.h
status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published)

if status:
    g.es("資料已經更新!")
else:
    g.es("有問題, 資料沒有更新!")
'''
其他 metaWeblog 的用法:
metaWeblog.newPost (blogid, username, password, struct, publish) returns string(postid)
metaWeblog.editPost (postid, username, password, struct, publish) returns true
metaWeblog.getPost (postid, username, password) returns struct(blog content)
'''</t>
<t tx="amd.20160309162721.8">execute-script predefines:

c: The commander of the present outline.
g: The leo.core.leoGlobals module.
p: The presently selected position, c.p.</t>
<t tx="amd.20160309174033.1"></t>
<t tx="amd.20160309175129.1">@language python
#coding: utf-8
import xmlrpc.client
# 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號
import html
 
#################################
filepath = "/home/amd/Desktop/www-code4future.txt"
wordpress = "www.code4future.org"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################

server = xmlrpc.client.ServerProxy(wp_url)

# 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資

# 從最後的 child 節點來取 post_id
origin_post = p.getLastChild()
post_id = origin_post.h
# 取回與 post_id 對應的網誌文章內容
blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password)
title = blog_content["title"]
# 這裡要利用 html.unescape 轉回特殊符號
description = html.unescape(blog_content["description"])
mt_text_more = html.unescape(blog_content["mt_text_more"])
if mt_text_more != "":
    post_content = description + "\n&lt;!--more--&gt;\n"+mt_text_more
else:
    post_content = description
# 所取回的 categories 為 list
categories = blog_content["categories"]
# 所取回的 tags 為以逗點隔開的字串
mt_keywords = blog_content["mt_keywords"]
# 取回文章作者
author = blog_content["wp_author_display_name"]
p.h = title
categories_str = ""
for category in categories:
    # 假如不是最後一個
    if category != categories[len(categories)-1]:
        categories_str += category + ", "
    else:
        # 這是最後一個
        categories_str += category
line1 = "@language md\n"
line2 = "Title: " +title + "\n"
line3 = "Category: " + categories_str + "\n"
line4 = "Tags: " + mt_keywords + "\n"
line5 = "Author: " + author + "\n@others\n"
post_content = post_content.replace('&lt;!--more--&gt;', '\n&lt;!-- PELICAN_END_SUMMARY --&gt;\n')
post_content = post_content.replace('[code lang="python"]', '~~~python')
post_content = post_content.replace('[/code]', '~~~')
p.b = line1 + line2 + line3 + line4 + line5 + post_content + "\n"
# 因為節點資料更新, commander 必須 redraw
c.redraw() 
g.es("資料已經取回")



</t>
<t tx="amd.20160309175129.2">俱備取回資料的權限

透過子節點的文章 id 與網誌網址, 以 xmlrpc 協定進行連線

取回 categories, tags, 文章標題與文章內容, 還有作者帳號?

分別按照格式, 將取回的資料放入對應節點

</t>
<t tx="amd.20160309191406.1">@language md
Title: 掌握未來, 速學編程
Category: K-12 學生
Tags: 導引
Author: code4future
@others
二十一世紀是數位運算與電腦編程充斥的世代.

&lt;!-- PELICAN_END_SUMMARY --&gt;

從小就學習程式的目的, 無非就是要這些未來的主人翁能夠及早了解數位系統的特性, 並且有效率地利用這些數位工具, 來解決類比世界所面臨的各種問題. 是的, 學習編程是要您用它來解決問題, 解決學習上的問題, 解決提升生活效能的問題, 解決單憑藉類比工具無法單獨解決的問題.
</t>
<t tx="amd.20160309191408.1"></t>
<t tx="amd.20160319074059.1"></t>
<t tx="amd.20160319074114.1"></t>
<t tx="amd.20160319074122.1"></t>
<t tx="amd.20160319123316.1">在這個 Leo Editor 專案中, 有 Pelican 靜態網誌系統的設定與實際將 md 檔轉為 html 的指令按鈕

而且每一則文章, 可以透過與 WP 對應的指令按鈕將文章轉換格式後, 送到對應的 Wordpress 動態網誌</t>
<t tx="amd.20160319123605.1">@language md
Title: 如何架構一個動靜皆宜的網誌系統
Category: 社會人士
Tags: 導引
Author: code4future
@others
全球資訊網上有兩種基本的 Blog 架構, 動態的網誌以 &lt;a href="https://wordpress.com/"&gt;Wordpress&lt;/a&gt; 為代表, 而靜態的網誌則以 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 為例.

&lt;!-- PELICAN_END_SUMMARY --&gt;

這一篇文章的目的, 在介紹 Code4Future 團隊如何利用 PHP、Python3, 在 OpenShift 雲端平台與 Github 版次管理系統中, 用同 Leo Editor 的專案架構, 以同一份內容, 幾乎同步地更新到動態與靜態的兩個網站.

首先, Code4Future 目前的動態網站為: &lt;a href="http://www.code4future.org"&gt;http://www.code4future.org&lt;/a&gt;, 而靜態網站則位於 &lt;a href="http://blog.code4future.org"&gt;http://blog.code4future.org&lt;/a&gt;.

其中的動態網站採用 &lt;a href="https://www.openshift.com/"&gt;Openshift&lt;/a&gt; 雲端平台建構, 而靜態網頁則架構在 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 上.

從 &lt;a href="https://github.com/code4futuretw/blogsite"&gt;https://github.com/code4futuretw/blogsite&lt;/a&gt; 倉儲, 可以取得 &lt;a href="http://blog.code4future.org"&gt;http://blog.code4future.org&lt;/a&gt; 靜態網誌上的所有資料 ,包括 Pelican 設定與 Leo Editor 專案檔中的所有按鈕指令程式碼.

首先來看, 如何在 OpenShift 建立一個 Wordpress 網誌:

1. 到 &lt;a href="https://www.openshift.com/"&gt;https://www.openshift.com/&lt;/a&gt; 申請一個帳號.
2. 收到 OpenShift 信件後, 按回電子郵箱的確認連結, 就可以開始在 OpenShift 雲端平台上建立應用程式.
3. 建立應用程式時, 選擇建立 Wordpress 類別的網誌, 並且選擇可用的網域名稱與應用程式名稱, 就可完成 Wordpress 起始設定.
4. 當建立 Wordpress 應用程式完成後, 使用者即可進行網誌的設定, 其中包括管理者帳號的建立與基本網誌設定.

至於 Github Pages 上的 &lt;a href="http://blog.code4future.org"&gt;http://blog.code4future.org&lt;/a&gt; 靜態網誌, 其架構則比較複雜, 一方面, 我們採用 &lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 來管理所有資料. 當使用者從 &lt;a href="https://github.com/code4futuretw/blogsite"&gt;https://github.com/code4futuretw/blogsite&lt;/a&gt; 倉儲 git clone 資料到本地端之後, 必須依靠 Python3, PyQt, Pelican 與 Git 才能順利在本地端與 Github Page 分支端, 順利建立並管理這個靜態網誌系統.

此外, 我們建構靜態網頁系統的目的, 是希望爾後在實體課堂中推廣 Code4Future 的各階段教材時, 可以無需上到廣域網路, 利用隨身硬碟與區域網路就能夠上課. 因此 Github 倉儲中的 Pelican 系統又分為本地端與雲端平台上的轉檔設定. 使用本靜態網頁時, 基本工作流程如下:

1. 從 &lt;a href="https://github.com/code4futuretw/blogsite"&gt;https://github.com/code4futuretw/blogsite&lt;/a&gt; 倉儲, git clone 資料到本地端.
2. 確定工作目錄中為倉儲的 gh-pages 分支內容.
3. 利用 Leo Editor 5.1 以後的版本, 開啟 users 目錄下的 c4f.leo, 就可以看到本站的所有資料.
4. 修改設定檔案內容.
5. 根據網誌 md 檔案中的格式, 編寫新網誌文章.
6. 先利用本地端所屬的 local-pelican 按鈕建立網誌文章.
7. 本地端內容查詢無誤後, 再用 gh-pages-pelican 按鈕, 產升即將送到雲端上的 Pelican 網誌內容

至於將 Pelican 中的 .md 檔案內容, 送到 Wordpress, 則配合 new-to-wp-pelican, edit-to-wp-pelican 與 get-from-wp-pelican 等3個按鈕指令.</t>
<t tx="amd.20160319132434.1"></t>
<t tx="amd.20160319222458.1">@language md
Title: CodeForLife 編程套件介紹
Category: K-12
Tags: 導引
Author: code4future
@others
Code for Life &lt;a href="https://www.codeforlife.education/"&gt;https://www.codeforlife.education/&lt;/a&gt; 是一套適合幼稚園到國小兒童使用的編程教育套件.

&lt;!-- PELICAN_END_SUMMARY --&gt;

Rapid Router 則是其中由英國 Ocado 公司在 &lt;a href="http://www.ocadotechnology.com/our-blog/articles/why-weve-open-sourced-code-for-life"&gt;2015 年 10 月份開源&lt;/a&gt;釋出的全球資訊網套件 (&lt;a href="https://github.com/ocadotechnology/rapid-router"&gt;Rapid Router Github 倉儲&lt;/a&gt;, &lt;a href="https://twitter.com/codeforlifeuk"&gt;Code for Life Twitter&lt;/a&gt;), 採用 Javascript 與 Python 編寫, 並且架構在 &lt;a href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; 全球資訊網框架上.

Rapid Router 從圖像編程入手, 規劃了適合 5-11 歲孩童電腦教學的教材, 並且逐步導入 Python 程式語法的教學, 其中的每一份教材都明確訂出進度與標的: &lt;a href="http://storage.googleapis.com/codeforlife-assets/general_resources/introduction_to_coding.pdf"&gt;http://storage.googleapis.com/codeforlife-assets/general_resources/introduction_to_coding.pdf&lt;/a&gt;.

同時, 老師註冊帳號後登入系統 ,就可以下載規劃完整的教學導引與學習評量內容, 儘管全部教材都是英文, 但若能夠藉由此份"快車找路"的類遊戲編程教學中, 讓孩童同時學習簡單的英文字句, 應該也是很不錯的額外收穫.</t>
<t tx="amd.20160319230246.1"></t>
<t tx="amd.20160319232117.1">@language md
Title: 數位運算博物館
Category: 專題研究
Tags: 數位運算, 電腦發展史
Author: code4future
@others
台灣是全世界重要的個人電腦生產國之一, 假如能夠有系統收集歷史上與數位運算相關的軟硬體相關資訊, 成立一個實體或虛擬的數位運算博物館, 那麼, 或許下一代年輕人能藉以鑑往知來, 在全球數位公民中扮演更重要的角色.

&lt;!-- PELICAN_END_SUMMARY --&gt;

英國運算博物館 (National Museum of Computing):

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/_Sw15F2QzMQ" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;

電腦發展史:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/computer_history_timeline.png" width="800" /&gt;

電腦博物館 (Computer Museum):

&lt;a href="https://en.wikipedia.org/wiki/The_Computer_Museum,_Boston"&gt;https://en.wikipedia.org/wiki/The_Computer_Museum,_Boston&lt;/a&gt;

&lt;a href="http://www.computerhistory.org/"&gt;http://www.computerhistory.org/&lt;/a&gt;

&lt;a href="http://tcm.computerhistory.org/"&gt;http://tcm.computerhistory.org/&lt;/a&gt;

從數位基礎到應用:

&lt;a href="http://www.nand2tetris.org/"&gt;http://www.nand2tetris.org/&lt;/a&gt;</t>
<t tx="amd.20160320001047.1">@language md
Title: 全雲端電腦輔助機械設計 3D 套件
Category: 社會人士
Tags: MCAD, CAD
Author: code4future
@others
一般人對於所謂的電腦輔助機械設計繪圖套件, 可能都還停留在單機 ,必須安裝, 必須經過軟硬體授權認証才能啟動的單機應用程式. 自從 2015 年3月份開始, 一群曾經在 1993 協助打造全世界第一套個人電腦操作系統上的 MCAD (Mechanical Computer Aided Design) 團隊, 推出了 OnShape, 從此您又多了一個選擇, 可以在各種電腦裝置 (包括手機與平板電腦) 上設計繪製 3D 的零組件, 不僅能與多人進行即時協同設計, 並且可以從擁有 500MB 到 5GB 的免費帳號開始入門.

&lt;!-- PELICAN_END_SUMMARY --&gt;

今天起, 請您暫時放下其他類似的 MCAD 套件, 開始關注: &lt;a href="https://www.onshape.com/"&gt;https://www.onshape.com/&lt;/a&gt;.

&lt;video controls autoplay="autoplay" width="800" height="600"&gt;
  &lt;source src="http://code4futuretw.github.io/blogsite_data/files/grab-windows700kb.mp4"&gt;
  Your browser does not support the video tag.
&lt;/video&gt;

&lt;video controls autoplay="autoplay" width="800" height="600"&gt;
  &lt;source src="http://code4futuretw.github.io/blogsite_data/files/ipad-air-720p_700kb.mp4"&gt;
  Your browser does not support the video tag.
&lt;/video&gt;

&lt;video controls autoplay="autoplay" width="800" height="600"&gt;
  &lt;source src="http://code4futuretw.github.io/blogsite_data/files/laptop-720p-apple700kb.mp4"&gt;
  Your browser does not support the video tag.
&lt;/video&gt;</t>
<t tx="amd.20160320145431.1"></t>
<t tx="amd.20160320182523.1">@language md
Title: Reeborg 機器人的兩個世界
Category: 教師
Tags: 導引
Author: code4future
@others
Reeborg 機器人世界是孩童學習 Python3 程式的一套有趣味性的工具, 從早期的單機程式, 到現在能夠直接在雲端主機或本地端進行練習操作, 正好見證了過去十幾年全球數位運算發展趨勢.

&lt;!-- PELICAN_END_SUMMARY --&gt;

因為目前 Reeborg 機器人程式碼中同時存在 JavaScript 與 Brython: &lt;a href="http://brython.info/"&gt;http://brython.info/&lt;/a&gt; 語法, 而作者也不斷在這兩種語言中進行各種切換測試, 這裡先提供最近版本中的兩個機器人世界:

&lt;a href="http://code4futuredotorg.github.io/reeborg_tw/world.html"&gt;http://code4futuredotorg.github.io/reeborg_tw/world.html&lt;/a&gt; (&lt;a href="https://github.com/code4futuredotorg/reeborg_tw"&gt;Github 倉儲&lt;/a&gt;)

&lt;a href="http://code4futuredotorg.github.io/reeborg2/"&gt;http://code4futuredotorg.github.io/reeborg2/&lt;/a&gt; (&lt;a href="https://github.com/code4futuredotorg/reeborg2"&gt;Github 倉儲&lt;/a&gt;)

上面這兩個網站都是採用 &lt;a href="https://pages.github.com/"&gt;Github Pages 技術&lt;/a&gt;, 已經將原始程式碼中的絕對根目錄資料設定, 改為相對目錄, 因此也能夠在本地端利用 python3 -m http.server 的方式啟動.

</t>
<t tx="amd.20160320184332.1"></t>
<t tx="amd.20160324163947.1"></t>
<t tx="amd.20160324163954.1"></t>
<t tx="amd.20160324171436.1">讓使用者可以使用 Mathematica (非營利使用免費)

sudo usermod -a -G video user_account

然後 sudo reboot 重新開機

但還是建議可以儘量使用 Python3 與 Jupyter 套件, 因為可以商業使用</t>
<t tx="amd.20160324172443.1">xdmcp 建立只在本地端區域網路中使用, 若需跨網連線, 建立使用 SSH

Raspberry Pi 端的設定:

https://www.raspberrypi.org/forums/viewtopic.php?f=26&amp;t=21246

Windows 使用 Xming

https://sourceforge.net/projects/xming/

xlaunch-&gt;選擇 xdmcp 連線</t>
<t tx="amd.20160324172457.1">xdmcp 建立只在本地端區域網路中使用, 若需跨網連線, 建立使用 SSH

Ubuntu 中安裝 remmina-remote_desktop 之後, 為了能夠利用 xdmcp 對本地端網路上的 Raspberry Pi3 連線, 必須再安裝：

remmina-plugin-xdmcp

參考:

http://packages.ubuntu.com/precise-updates/gnome/remmina-plugin-xdmcp

Raspberry Pi 端的設定:

https://www.raspberrypi.org/forums/viewtopic.php?f=26&amp;t=21246</t>
<t tx="amd.20160324173857.1">安裝 texlive

sudo apt-get install texlive-full

sudo apt-get update
sudo apt-get upgrade
sudo apt-get install kile
sudo apt-get install okular</t>
<t tx="amd.20160324174604.1">https://en.wikipedia.org/wiki/Bring_your_own_device

refers to the policy of permitting employees to bring personally owned mobile devices (laptops, tablets, and smart phones) to their workplace, and to use those devices to access privileged company information and applications.

建議硬體:

http://www.amazon.com/CanaKit-Raspberry-Complete-Starter-Kit/dp/B01C6Q2GSY/</t>
<t tx="amd.20160324193327.1">@language md
Title: 為小孩準備一台電腦
Category: 家長
Tags: 導引
Author: code4future
@others
是的, 您要為已經五歲的小孩準備一台電腦, 以下是我們的建議. 24吋螢幕的一台電腦總價格約為新台幣 7731 元.

&lt;!-- PELICAN_END_SUMMARY --&gt;

體積龐大的桌上型電腦並非為小孩準備電腦的首選, 因為世界趨勢已經指向所謂的物聯網與工業 4.0, 可攜、低價並且能隨著孩童成長, 配合數位運算與機電控制"自造"學習的卡片型電腦才是正確的選擇.

&lt;pre class="brush: python;"&gt;
# 在台灣買樹莓派卡片電腦, 大約是台幣 1338 起跳
raspberrypi3 = 1338
# 有開關的 USB 式電源線, 可以從接上 110V 插座, 也可以從 電腦的 USB 插槽接電, 大約台幣 250 元
power = 250
# 內建 Noobs 的 32 GB 記憶卡, 賣價 400 元台幣
sdcard = 400
# 樹莓派的專用外殼, 要價台幣 275 元
case = 275
# 24 吋, 擁有 HDMI 接頭的螢幕, 大約台幣 4~5 千元
philips = 3988 
# hdmi 接線, 130 元
hdmi = 130
# 微軟的鍵盤加上滑鼠, 最便宜的大約 590 元
microsoft = 590
# 耳機一副約 760 元
earphone = 760
try:
    g.es(raspberrypi3+power+sdcard+case+philips+hdmi+microsoft+earphone)
except:
    print(raspberrypi3+power+sdcard+case+philips+hdmi+microsoft+earphone)
#總價為新台幣: 7731 (201603)
&lt;/pre&gt;

卡片電腦: &lt;a href="http://code4futuretw.github.io/blogsite_data/files/rs-online_com.png"&gt;&amp;nbsp;&lt;/a&gt;

要注意的是 2016 年2月起最新的是 64 位元內建  Wifi 的 Raspberry Pi 3, 在國外定價為美金 35 元, 在台灣大約 1338 元是最低價.

電源供應器: &lt;a href="http://code4futuretw.github.io/blogsite_data/files/5v2a_usb_powersupply.png"&gt;&amp;nbsp;&lt;/a&gt;

最好買 USB 式的 5V2A 規格, 若正好在筆電或桌上型電腦旁邊使用, 可以透過 USB 接線供電.

含操作系統記憶卡(32GB): &lt;a href="http://code4futuretw.github.io/blogsite_data/files/32gb_noobs_kingston.png"&gt;&amp;nbsp;&lt;/a&gt;

32 GB 大概是目前最划算的規格, 記得買內建 &lt;a href="https://www.raspberrypi.org/downloads/noobs/"&gt;Noobs&lt;/a&gt; 操作系統資料的版本.

電腦卡外殼: &lt;a href="http://code4futuretw.github.io/blogsite_data/files/raspberrypi3_case.png"&gt;&amp;nbsp;&lt;/a&gt;

螢幕: &lt;a href="http://code4futuretw.github.io/blogsite_data/files/philips_24_hdmi.png"&gt;&amp;nbsp;&lt;/a&gt;

記得要買支援 HDMI 接頭的電腦螢幕.

HDMI 連接線: &lt;a href="http://code4futuretw.github.io/blogsite_data/files/sony_hdmi_2m.png"&gt;&amp;nbsp;&lt;/a&gt;

可以買 1.4 到 2 米的 Raspberry Pi 專用連接線.

鍵盤與滑鼠: &lt;a href="http://code4futuretw.github.io/blogsite_data/files/microsoft_kb_mouse.png"&gt;&amp;nbsp;&lt;/a&gt;

建議買 Microsoft 最低價的型號即可 (我們的經驗是, 能夠標上 Microsoft 商標的電腦週邊硬體, 都是不錯的選擇).

耳機: &lt;a href="http://code4futuretw.github.io/blogsite_data/files/audio_tech_earphone.png"&gt;&amp;nbsp;&lt;/a&gt;

選擇單邊線而且可折疊的機型, 使用或收藏都比較方便.</t>
<t tx="amd.20160324201508.1">raspberrypi3 = 1338
power = 250
sdcard = 400
case = 275
philips = 3988 
hdmi = 130
microsoft = 590
earphone = 760
try:
    g.es(raspberrypi3+power+sdcard+case+philips+hdmi+microsoft+earphone)
except:
    print(raspberrypi3+power+sdcard+case+philips+hdmi+microsoft+earphone)
</t>
<t tx="amd.20160324221453.1">https://github.com/kleinee/jns</t>
<t tx="amd.20160330005047.1">@language md
Title: 學習寫電腦程式的目的與意義
Category: 家長
Tags: 導引
Author: code4future
@others
電腦編程的目的, 在能以客製隨選的方法解決問題, 而數位運算與思維的意義, 則希望從電腦的觀點提供解決方案.

&lt;!-- PELICAN_END_SUMMARY --&gt;

程式 (program) 其實是一種流程規劃, 通常以精確定義的法則, 安排特定順序, 來產生特定的結果. 換言之, 學習寫程式可以與數位運算無關, 當然也就不一定要使用電腦. 但是數位運算的精確與快速, 帶來的體貼與便利性, 讓全世界各國開始希望其國民從小就能夠學習寫電腦程式, 因此學習寫電腦程式的目的在於:

1. 讓學童在俱備高度彈性的數位世界裡學習, 透過影音多媒體的教材提高學習興趣.

2. 讓學童及早接觸數位環境, 學習如何利用數位方法解決周遭的問題.

在數位世界裡, 最底層的運算單元雖然只有 0 與 1, 但是透過巧妙的安排, 可以利用單純且不易出錯的流程來進行數位運算, 可以利用相同的媒體來儲存各種不同的資料, 可以利用光速的方法來傳遞數據, 可以操控接近原子大小的精密製造流程來製造晶片, 可以利用演化與學習的模式來建立人工智慧. 這些相關技術與軟硬體產品的特性, 都是二十一世界各領域學生所必須儘早理解並掌握的知識.

以電腦網路協定來說, 目前主流的網路協定稱為 TCPIP, 早期使用的版本為第四版, 而目前正在推動的則為第六版, 以 IPV6 來說, 其網路位址的個數為 2 的 128 次方 (以冒號區隔, 共分八區, 每一區有 4 個十六進位的數字), 理論上足夠分配給整個地球每一個帶電原子各一個網路位址.

以電腦的運算能力來說, 目前的 64 位元個人電腦的運算能力比二十年前的超級電腦都強.

以感測器的製造能力來說, 隨著奈米技術的應用, 感測器愈做愈小, 而且單價愈來愈便宜.

以網路通信訊號的普及率來說, 在人類經常活動的區域範圍, 幾乎網路通信連線機制已經無所不在.

以實體產品的組裝與製造技術來說, 愈來有愈多的智慧型機器人被導入生產流程之中, 不僅取代煩雜的勞務人力工作, 而且已經俱備全球連線彈性客製的能力.

從以上的幾個面向來看, 及早學習寫電腦程式的目的, 就在於能讓學習者及早融入數位化運算充斥的未來環境, 而積極意義則在於, 希望這些未來學子能夠充份運用這些成熟的科技來改善環境, 有機會利用數位科技促進群體社會的永續發展.





</t>
<t tx="amd.20160410201430.1"></t>
<t tx="amd.20160410201430.2">@language python
import os
# 節點的 body 內容設為 content
content = p.b
with open('test.diag', 'w') as f:
    f.write(content)
f.closed
# 存為 svg
#os.system("blockdiag -Tsvg test.diag" )
# 存為 png, 使用 fireflysung.ttf
os.system("blockdiag -f fireflysung.ttf test.diag" )
#os.system("blockdiag test.diag" )
g.es("已經存 test.png 檔案")</t>
<t tx="amd.20160410201430.3">
blockdiag {
    default_shape = roundedbox;
    // 內定寬度為 128
    node_width = 140;
    // 內定高度為 40
    node_height = 50;
    default_fontsize = 15;
    default_node_color = "lightyellow";
    edge_layout = flowchart;
    // 表達方式
    表達 [label = "六種表達方式"];
    1 [label = "口語表達(聲音)"];
    2 [label = "文字表達", color="#99ff33"];
    3 [label = "2D表達(靜態影像)"];
    4 [label = "3D表達(動態影像)"];
    5 [label = "理論表達(定量分析)"];
    6 [label = "實體表達", color="#99ff33"];
    表達 -&gt; 1;
    表達 -&gt; 2;
    表達 -&gt; 3;
    表達 -&gt; 4;
    表達 -&gt; 5;
    表達 -&gt; 6;
    // 學門
    學門 [label = "四種技術領域"];
    學門1 [label = "熱流力學"];
    學門2 [label = "固體力學"];
    學門3 [label = "電機電子"];
    學門4 [label = "資訊通信", color="#99ff33"];
    學門 -&gt; 學門1;
    學門 -&gt; 學門2;
    學門 -&gt; 學門3;
    學門 -&gt; 學門4;
    // 流程
    流程 [label = "四個層面"];
    流程1 [label = "設計", color="#99ff33"];
    流程2 [label = "製造"];
    流程3 [label = "控制"];
    流程4 [label = "管理", color="#99ff33"];
    流程 -&gt; 流程1;
    流程 -&gt; 流程2;
    流程 -&gt; 流程3;
    流程 -&gt; 流程4;
    //專題
    //專題 [label = "機械設計專題", stacked];
    專題 [label = "隨身卡片電腦選購", stacked, color="#ff5050"];
    專題 -&gt; 表達;
    專題 -&gt; 流程;
    專題 -&gt; 學門;
}
</t>
<t tx="amd.20160410201430.4">@language python
import os
# 節點的 body 內容設為 content
content = p.b
with open('test.diag', 'w') as f:
    f.write(content)
f.closed
# 存為 svg
#os.system("nwdiag -Tsvg test.diag" )
# 存為 png, 使用 fireflysung.ttf
#os.system("nwdiag -f fireflysung.ttf test.diag" )
os.system("nwdiag test.diag" )
g.es("已經存 test.png 檔案")</t>
<t tx="amd.20160410201430.5">/*
nwdiag {
  network dmz {
      address = "210.x.x.x/24"

      web01 [address = "210.x.x.1"];
      web02 [address = "210.x.x.2"];
  }
  network internal {
      address = "172.x.x.x/24";

      web01 [address = "172.x.x.1"];
      web02 [address = "172.x.x.2"];
      db01;
      db02;
  }
}
*/

nwdiag {
    default_fontsize = 15;
    校主幹 [shape = cloud];
    校主幹 -- 系路由器;
    
    network 系主幹{
        address = "140.130.17.0/24";
        系路由器 [address="140.130.17.254"];
        雲端點名網路;
        八樓集線器 [address="140.130.17.82"];
        七樓集線器;
        六樓集線器;
        系伺服器群;
    }
    
    network 八樓主幹{
        address="17.10-82"
        八樓集線器 [address="140.130.17.82"];
        老師1伺服器群 [address="140.130.17.10-15"];
        老師2伺服器群 [address="140.130.17.16-25"];
        老師3伺服器群 [address="140.130.17.26-60"];
    }
    
    network CAD_CAE{
        address="17.83";
        八樓集線器 [address="140.130.17.82"];
        CAD_NAT [address="140.130.17.82"];
        CAE_NAT [address="140.130.17.83"];
    }
    
    network 電腦輔助設計室{
        address="192.168.1.0/24";
        CAD_NAT [address="192.168.1.1"];
        CAD1 [address=".2"];
        CAD2;
        CAD64 [address=".100"];
    }
    
    network 電腦輔助繪圖室{
        address="192.168.1.0/24";
        CAE_NAT [address="192.168.1.1"];
        CAE1 [address=".2"];
        CAE2;
        CAE64 [address=".100"];
    }
    
    network 七樓主幹{
        address="140.130.17.83-90"
        七樓集線器;
        老師4伺服器群 [address="140.130.17.61-63"];
        老師5伺服器群 [address="140.130.17.64-70"];
        老師6伺服器群 [address="140.130.17.71-75"];
    }
    
    network 六樓主幹{
        address="140.130.17.91-100"
        六樓集線器;
        老師7伺服器群 [address="140.130.17.76-78"];
        老師8伺服器群 [address="140.130.17.79-80"];
        老師9伺服器群 [address="140.130.17.81-95"];
    }
}</t>
<t tx="amd.20160410201438.1">
blockdiag {
    default_shape = roundedbox;
    // 內定寬度為 128
    node_width = 140;
    // 內定高度為 40
    node_height = 50;
    default_fontsize = 15;
    default_node_color = "lightyellow";
    edge_layout = flowchart;
    code4future [label = "克服未來"]
    // 服務對象
    對象 [label = "四種服務對象"];
    1 [label = "未成年兒童"];
    2 [label = "家長"];
    3 [label = "教師"];
    4 [label = "社會人士"];
    對象 -&gt; 1;
    對象 -&gt; 2;
    對象 -&gt; 3;
    對象 -&gt; 4;
    // 任務
    任務 [label = "任務"];
    數位運算 [label = "數位運算"];
    編程教學 [label = "編程教學"];
    任務 -&gt; 數位運算;
    任務 -&gt; 編程教學;
    // 工具
    工具 [label = "工具"];
    數位教材 [label = "數位教材"];
    BYOD [label = "自帶筆電"];
    RPI [label = "樹莓派電腦"];
    3DP [label = "3D 印表機"];
    SS [label = "3D 參數繪圖"]
    OS [label = "3D 雲端繪圖"]
    VREP [label = "動態模擬"]
    工具 -&gt; 數位教材;
    工具 -&gt; BYOD;
    工具 -&gt; RPI;
    工具 -&gt; 3DP;
    工具 -&gt; SS;
    工具 -&gt; OS;
    工具 -&gt; VREP;
    //手段
    手段 [label = "手段"];
    電腦程式設計 [label = "電腦程式設計"]
    3D_製圖 [label = "3D 製圖"]
    數位模擬 [label = "數位模擬"]
    3D_列印 [label = "3D 列印"]
    機電控制 [label = "機電控制"]
    手段 -&gt; 電腦程式設計;
    手段 -&gt; 3D_製圖;
    手段 -&gt; 數位模擬;
    手段 -&gt; 3D_列印;
    手段 -&gt; 機電控制;
    //C4F
    code4future -&gt; 對象
    code4future -&gt; 任務
    code4future -&gt; 工具
    code4future -&gt; 手段
}
</t>
<t tx="amd.20160712092639.1"></t>
<t tx="amd.20160712092645.1"></t>
<t tx="amd.20160712092649.1"></t>
<t tx="amd.20160712092655.1"></t>
<t tx="amd.20160712094256.1">@language md
Title: 我們如何利用程式方法解決自己的問題
Category: 社會人士
Tags: 專題研究, 網誌架構
Author: code4future
@others
在這篇文章中, 我們介紹如何利用 Python3 程式的特性與工具來解決我們在網誌發表上所面臨的問題.

&lt;!-- PELICAN_END_SUMMARY --&gt;

一般在網路上發表網誌有動態與靜態等兩種選擇, 所謂動態網誌, 就是網誌系統直接在全球資訊網路上提供編修文章與管理的功能, 使用者可以直接利用全球資訊網瀏覽器, 以帳號登入網誌管理系統, 依照使用者權限管理內容.

動態網誌的好處就是即時而且靈活, 但是壞處則是資料的傳送必須透過全球資訊網程式處理後, 轉為 html 資料格式, 因此使用者擷取網誌內容的反應速度, 較事先已經轉成 html 的靜態網誌慢, 而另外一個壞處則是, 動態網誌將管理系統直接放在全球資訊網伺服器上, 儘管可以透過各種安全防護機制加以保護, 但是仍然帶有被駭客入侵修改內容的風險.

至於靜態網誌則是使用者利用各種方式編修網誌內容後, 將已經轉成 html 格式的內容送到全球資訊網伺服器, 而在 WWW 伺服器中並沒有提供任何用來管理網誌內容的程式, 因此好處是被擷取的反應速度較動態網誌快, 並且少掉被駭客入侵網誌管理系統的機會, 只有駭客攻破提供全球資訊網伺服器的雲端架構, 靜態網誌內容才可能受到破壞. 而靜態網誌的缺點則是無法像動態網誌一樣, 即時直接讓使用者在瀏覽器中編修文章內容.

了解動態網誌與靜態網誌的特性後, 一般使用者在建立網誌的過程中, 若希望能夠透過即時協同的方式, 多人共同管理網誌文章, 並且能夠有效保存各階段性的網誌文章內容. 大多採用動態網誌系統. 但是若想要利用類似 Github Pages 的架構, 利用分散式資料管理系統, 例如 GIT, 來管理每一個版本的內容, 則靜態網將會是比動態網誌更適合.

以 Code4Future 來說, 我們想要同時擁有上述動態與靜態網誌的優點, 但是又必須儘量讓兩個不同系統的內容能夠同步, 於是我們想出利用程式方法來媒合兩種風格迥異的網誌系統.

基本的作法如下：

1. 我們其實是同時建立一個 Wordpress 靜態網誌系統與靜態的 Python3 Pelican 網誌系統.

2. Wordpress 網誌系統的用法與一般動態網誌的管理模式相同, 可以讓負責協同的人員建立帳號, 依照帳號權限管理網誌內容.

3. Python3 Pelican 的靜態網誌建立, 也採用一般靜態網誌的建立與上傳方法, 只是我們選擇利用 Github Pages 來伺服我們的靜態網誌.

4. 結合 Wordpress 與 Pelican 網誌內容的基本技術植基於 &lt;a href="https://zh.wikipedia.org/wiki/XML-RPC"&gt;XML-RPC&lt;/a&gt; 協定, 因為 Wordpress 是採用 PHP 程式語言編寫, 而 Pelican 則是採用 Python 程式語言, 假如沒有中繼的 XML-RPC 協定來轉換兩者的資料內容, 使用者就必須從 Wordpress 儲存資料的資料庫系統下手.

5. 另外一個重要的程式架構則是, 我們選擇以 &lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 來管理這個資料互動的程式流程.

6. 由於從 Pelican 靜態網誌系統將資料轉進或轉出 Wordpress 時, 需要擁有管理資料的帳號密碼, 這時我們利用存在使用者電腦特定位置的帳號密碼讀取, 來登入 Wordpress 系統.

7. 假如原始網誌內容先在 Wordpress 建立, 則位於 Leo Editor 專案中的 Pelican 靜態網誌管理系統可以利用 get-from-wp 按鈕將資料取回.

8. 假如原始網誌內容先在 Pelican 建立, 則可以利用 Leo Editor 的 new-to-wp 按鈕, 將靜態網誌內容推向 Wordpress.

9. 假如 Wordpress 網誌內容更動, 則 Pelican 可以再利用 get-from-wp 按鈕取回最新的資料.

10. 假如位於 Pelican 管理系統中的網誌內容更動, 則可以利用 Leo Editor 的 edit-to-wp 按鈕將更新資料推向 Wordpress.

以下為實際的 Leo Editor 按鈕程式碼:

new-to-wp-button

~~~python
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &amp;lt;!-more-&amp;gt;
    content = content.replace('&amp;lt;!-- PELICAN_END_SUMMARY --&amp;gt;', '&amp;lt;!--more--&amp;gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
    
os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/home/amd/Desktop/www-code4future.txt"
wordpress = "www.code4future.org"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
# 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}
 
post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published)
# 利用最後的 child 節點來儲存 post_id
to_save_post_id = p.insertAsLastChild()   
# 改為內文為空的節點, id 直接標在 head 標題 
to_save_post_id.b = ""
to_save_post_id.h = post_id
# 因為新增節點, commander 必須 redraw
c.redraw() 

g.es("post_id 為", post_id)
g.es("已經送出資料!")
~~~

edit-to-wp-button

~~~python
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &amp;lt;!-more-&amp;gt;
    content = content.replace('&amp;lt;!-- PELICAN_END_SUMMARY --&amp;gt;', '&amp;lt;!--more--&amp;gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content
    
os.environ['TZ'] = 'Asia/Taipei'
 
#################################
filepath = "/home/amd/Desktop/www-code4future.txt"
wordpress = "www.code4future.org"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"
 
status_draft = 0
status_published = 1
 
server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

# 設法取得原 post 的 id
origin_post = p.getLastChild()
# 直接從標題取得 post 的 id 號碼
post_id = origin_post.h
status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published)

if status:
    g.es("資料已經更新!")
else:
    g.es("有問題, 資料沒有更新!")
~~~

get-from-wp button

~~~python
#coding: utf-8
import xmlrpc.client
# 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號
import html
 
#################################
filepath = "/home/amd/Desktop/www-code4future.txt"
wordpress = "www.code4future.org"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################

server = xmlrpc.client.ServerProxy(wp_url)

# 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資

# 從最後的 child 節點來取 post_id
origin_post = p.getLastChild()
post_id = origin_post.h
# 取回與 post_id 對應的網誌文章內容
blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password)
title = blog_content["title"]
# 這裡要利用 html.unescape 轉回特殊符號
description = html.unescape(blog_content["description"])
mt_text_more = html.unescape(blog_content["mt_text_more"])
if mt_text_more != "":
    post_content = description + "\n&amp;lt;!--more--&amp;gt;\n"+mt_text_more
else:
    post_content = description
# 所取回的 categories 為 list
categories = blog_content["categories"]
# 所取回的 tags 為以逗點隔開的字串
mt_keywords = blog_content["mt_keywords"]
# 取回文章作者
author = blog_content["wp_author_display_name"]
p.h = title
categories_str = ""
for category in categories:
    # 假如不是最後一個
    if category != categories[len(categories)-1]:
        categories_str += category + ", "
    else:
        # 這是最後一個
        categories_str += category
line1 = "@language md\n"
line2 = "Title: " +title + "\n"
line3 = "Category: " + categories_str + "\n"
line4 = "Tags: " + mt_keywords + "\n"
line5 = "Author: " + author + "\n@others\n"
post_content = post_content.replace('&amp;lt;!--more--&amp;gt;', '\n&amp;lt;!-- PELICAN_END_SUMMARY --&amp;gt;\n')
post_content = post_content.replace('[code lang="python"]', '~~~python')
post_content = post_content.replace('[/code]', '~~~')
p.b = line1 + line2 + line3 + line4 + line5 + post_content + "\n"
# 因為節點資料更新, commander 必須 redraw
c.redraw() 
g.es("資料已經取回")
~~~
</t>
<t tx="amd.20160712231633.1"></t>
<t tx="amd.20160715215651.1">@language md
Title: 我們如何建立這個網站 (一)
Category: 社會人士
Tags: 專題研究, 網誌架構, Wordpress, Godaddy, OpenShift
Author: code4future
@others
在這篇文章中, 我們將介紹 code4future 的網誌是如何建立的.

&lt;!-- PELICAN_END_SUMMARY --&gt;

這幾天我們發現, 大約在一年之前利用 OpenShift 雲端平台所搭建的 Wordpress 網站, 幾乎全部都被駭客攻陷, 根據初步的了解, 駭客是從 OpenShift 雲端平台啟動的程式碼置入惡意軟體, 讓連結到這些網站的用戶, 被強迫指到一些惡意網站, 因此這些 Wordpress 網站在修復之前, 幾乎已經完全癱瘓, 已經無法正常運作. 在此希望我們這個網站不會有這樣的下場.

首先, 先來看看, 一個網站之所以能被使用者連結所需要的幾項元素:

1. 網站符號名稱.
2. 全球資訊網伺服器.
3. 執行網誌功能的程式套件.
4. 依附在網誌套件上的其他延伸功能套件.

以 code4future.org 網站來說, 這個網址是在 Godaddy 服務商購買的, 網址所對應的 DNS 設定也是交由 Godaddy 處理.

至於 code4future.org 網站的全球資訊伺服器採用 OpenShift 的雲端平台服務, 而 OpenShift 是建構在 RedHat 操作系統上, 而在雲端操作系統上, OpenShift 採用的全球伺服器是 Apache, 我們只要有一個能夠收信的電子郵箱, 就能夠在 OpenShift 雲端平台上登記帳號, 也能夠很快建立各種雲端伺服應用程式, 也就能夠使用 OpenShift 所提供的全球伺服器服務.

第 3 項, code4fugure.org 網站所使用的網誌是 Wordpress, 這是一套利用 PHP 程式語言所編寫的 Blog 套件, 至於與套件結合的資料庫, 則是採用 MySQL 系統.

至於第 4 項則是在 Wordpress 建立完成之後, 為了要延伸網誌的功能, 可以增加 Plugin 套件, 就 code4future.org 的網誌來說, 最重要的延伸功能就是將原先的留言系統改為 disqus 系統, 以方便使用者可以透過 disqus, gmail, facebook 或 twitter 等網站的帳號登入留言.

好了, 為了要在 OpenShift 建立一個  Wordpress 網站, 我們需要一個 Gmail 電子郵箱.

Step 1:

登入到您的 Gmail 電子郵箱, 登入後將會在第 2 步完成 OpenShift 帳號登記後, 再回到 Gmail 來點按確認信連結.

說明: 因為當我們在 OpenShift 雲端平台登記帳號後, OpenShift 會寄出確認信, 我們必須回覆確認信後, 才能夠在 OpenShift 平台上建立全球資訊網應用程式.

以下為登入到 Gmail 的畫面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_logintogmail.png" width="800" /&gt;

Step 2:

利用瀏覽器, 連結到 &lt;a href="https://www.openshift.com/"&gt;https://www.openshift.com/&lt;/a&gt;, 然後利用步驟 1 的 Gmail 電子郵箱帳號, 登記一個 OpenShift 雲端平台帳號. 登記完成後, OpenShift 會以登記的 Gmail 帳號寄出確認信件, 使用者必須確認擁有所登記的電子郵箱後, 才能開始使用 OpenShift.

從下圖可以看到右上方 Sign up for free 的紅色連結:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_signupopenshift.png" width="800" /&gt;

下圖則為 Sign up OpenShift 帳號的畫面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_signupopenshift1.png" width="800" /&gt;

下圖則為登記 OpenShift 帳號後, 系統會寄出一封驗證電子郵箱擁有人的信件:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_signupopenshift2.png" width="800" /&gt;

Step 3:

當使用者完成 OpenShift 帳號登記的確認流程後, 就可以從 &lt;a href="https://openshift.redhat.com/app/login"&gt;https://openshift.redhat.com/app/login&lt;/a&gt;, 以所登記的帳號密碼登入 OpenShift.

下圖則為登入 OpenShift 雲端平台後的畫面, 可以開始建立應用程式:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_logintoopenshift.png" width="800" /&gt;

Step 4:

當使用者登入 OpenShift 平台後, 就可以利用 Create your first application now 連結, 建立一個 Wordpress 4 的雲端網站. 當首次在 OpenShift 雲端平台上建立應用程式, 必須要選擇一個應用程式所屬的 namespace, 也就是 RedHat 用來建立網站網址的重要依據, 例如我們在這個範例中, 所選擇的 namespace 為 topuniversity, 因此隨後所建立的網站應用程式的網址都將以 topuniversity.rhcloud.com 作為網址符號名稱的後半段, 而前半段, 則是使用者所選擇的應用程式名稱, 例如我們選擇目前所建立的 OpenShift 雲端平台應用程式名稱為 wp, RedHat 就會將此應用程式的網址設為 wp-topuniversity.rhcloud.com

選擇好 namespace 與 application name 之後, 按下 Create Application, 就可以完成此一應用程式的建立.

從下圖可以看到建立應用程式時, 選擇建立 Wordpress 4 應用程式:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_createwordpresssite.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_createwordpresssite1.png" width="800" /&gt;

下圖則是設定 namespace 與應用程式名稱的畫面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_namespace_app_name.png" width="800" /&gt;

完成應用程式建立的畫面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_openshiftappcreated.png" width="800" /&gt;


Step 5:

當 OpenShift 雲端平台上的 Wordpress 應用程式建立完成後, 我們選擇 Visit app in the browser, 就可以開始在雲端安裝 Wordpress. 我們選擇以英文介面安裝, 接著輸入 Site Title, 以及網站管理者的帳號與密碼, 還有電子郵箱, 並註記是否要讓搜索引擎搜尋網站內容選項後, 按下 install Wordpress, 就可以開始進行安裝.

完成 Wordpress 應用程式建立後, 點選網站進入後, 可以開始安裝 Wordpress, 先選擇安裝的語系:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_startwpinstall.png" width="800" /&gt;

接著選擇網站名稱, 以及管理者的帳號密碼, 以及電子郵箱等:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_wordpressinstallwelcome.png" width="800" /&gt;

安裝完成後, OpenShift 平台會傳回 Success 的畫面. 接著點下 login, 網站就會以 https 協定, 跳轉到 Wordpress 的登入畫面.

下圖則是成功完成 Wordpress 安裝的畫面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_wordpresssucess.png" width="800" /&gt;

恭喜您, 您已經在 OpenShift 雲端平台上建立了一個 Wordpress 網站, 以現在所建立的範例網誌為例 ,就是 &lt;a href="http://wp-topuniversity.rhcloud.com"&gt;http://wp-topuniversity.rhcloud.com&lt;/a&gt;

下圖則是登入畫面, 特別注意必須在 https 模式下才可以輸入帳號密碼:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_wordpressfirstlogin.png" width="800" /&gt;

下圖則已經以管理者身份登入 Wordpress:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_wordpresslogintoadmin.png" width="800" /&gt;

下圖則是採用內建 theme 主題的 Wordpress 網站畫面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_wordpresscreated.png" width="800" /&gt;


Step 6:

改用 awesomeone theme, 當以管理者身份登入 Wordpress 網站後, 選擇 Appearance-&gt;Themes, 然後選擇 Add new, 並且以 Awesomeone 關鍵字搜尋, 就可以找到 Awesomeone theme, 選擇 install 並 activate, 就可以改用 Awesome theme 主題了.

下圖可以看到, Wordpress 所採用的 default theme:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_wordpressdefaulttheme.png" width="800" /&gt;

下圖顯示我們可以利用 add new theme, 安裝選用新的網站 theme 主題:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_addnewtheme1.png" width="800" /&gt;

下圖顯示安裝並啟用 Awesomeone theme 主題:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_awesomeonetheme.png" width="800" /&gt;

最後完成啟用 Awesomeone theme 的 Wordpress 網站畫面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/openshift/c4f_awesomeonetheme1.png" width="800" /&gt;

總結

在這篇說明中, 我們利用 Gmail 帳號, 在 OpenShift 雲端平台登記了一個免費帳號, 並且利用這個免費帳號, 建立的一個 Wordpress 網站: &lt;a href="https://wp-topuniversity.rhcloud.com/"&gt;https://wp-topuniversity.rhcloud.com/&lt;/a&gt;, 這個網站使用了 Awesomeone theme, 但是除了內建的 plugin 外, 還沒有啟用其他 plugin, 在隨後的說明, 我們將說明如何將 OpenShift 所建立的網誌與 Godaddy 的網址對應, 而且還要說明如何在 Wordpress 網站中啟用 Disqus 留言系統.</t>
<t tx="amd.20160716001133.1"></t>
<t tx="amd.20160717151500.1">@language md
Title: 我們如何建立這個網站 (二)
Category: 社會人士
Tags: 專題研究, 網誌架構, Wordpress, Godaddy, OpenShift
Author: code4future
@others
在上一篇文章中, 我們介紹了如何利用 Gmail 郵箱在 OpenShift 雲端平台上登記免費的帳號, 如何在 OpenShift 建立 Wordpress 網站, 如何更改 theme 頁面主題, 而這個 OpenShift 平台上的 Wordpress 網站所使用的網址, 是由 OpenShift 提供, 主要是以使用者建立的應用程式名稱, 加上使用者所選的 namespace, 然後再疊上 rhcloud.com.

&lt;!-- PELICAN_END_SUMMARY --&gt;

在這篇文章中, 我們將說明如何在 Godaddy DNS 設定中, 利用 www 當作主機代號, 疊上我們所購買的 domain name (也就是 code4future.org), 並且利用 DNS 架構中的 CNAME (別名) 將這個網址指到 OpenShift 的 Wordpress 網站, 最後再登入到 OpenShift 平台, 將原先 RedHat 附贈的網站名稱改為 Godaddy DNS 管理中所設定的網址名稱, 就可以完成使用我們所購買的 domain name 來跑 OpenShift 上的 Wordpress 網誌網站.

接下來的操作步驟, 目的就是要將第一篇我們已經完成的 Wordpress 網站網址, 對應為我們所購買的符號名稱, 也就是我們要將 wp-topuniversity.rhcloud.com 改為 demo.code4future.org.

這個設定, 總共牽涉到 3 個基本操作:

1. Godaddy 帳號中的 DNS 管理.

2. Wordpress 網站中的網址設定.

3. OpenShift 平台上應用程式改用新的對應網址設定.

以實際操作流程為例, 我們在第 1 項 Godaddy 帳號中的 DNS 管理, 就是要利用 CNAME 設定, 將 demo.code4future 指向 wp-topuniversity.rhcloud.com.

而第 2 項 Wordpress 的設定, 就是要將原先建立應用程式時所選擇的網址 wp-topuniversity.rhcloud.com 改為 demo.code4future.org.

至於第 3 項則需要登入到 OpenShift, 進入 wp-topuniversity.rhcloud.com 應用程式的設定區, 把原先網站使用的 wp-topuniversity.rhcloud.com 改為 demo.code4future.org.

Stpe 1:

首先必須登入 Godaddy.

登入後的畫面如下:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy1.png" width="800" /&gt;

點選 Domains, 進入類似下列的畫面, 選擇要管理的 domains 名稱列, 點選其後的 Manage DNS 連結:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy2.png" width="800" /&gt;

進入 DNS Management 畫面後, 可以看到 Records 右下方有一個 Add 按鈕:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy3.png" width="800" /&gt;

這時要建立一個 Record Type 為 CNAME 的 DNS 紀錄, 因此在按下 Add 之前, 必須先從左下方的選單中, 選擇 CNAME:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy4.png" width="800" /&gt;

按下 Add 之後, 必須分別在 CNAME 紀錄選單中的 Host 欄位與 Points to 欄位填上網站的名稱, 下列畫面的 Host 名稱, 填入 www, 表示要在 code4future.org 網域中 (請特別注意, Host 欄位中只需要填入 www 或 demo, 而不要填入 www.code4future.org 或 demo.code4future.org), 新增一個 Host 名稱為 www, 若再疊上網域, 網站名稱就成為 www.code4future.org, 假如在 Host 欄位填上 demo, 表示這個 CNAME 別名網站的網址就會是 demo.code4future.org.

至於 Points to 欄位, 表示這個 domain 網址別名要指向那一個網站, 在此案例中, 我們希望 demo.code4future.org 能夠指向 wp-topuniversity.rhcloud.com, 因此在 Points to 欄位中就必須填入 wp-topuniversity.rhcloud.com, 如下列畫面所示:

另外, 下列畫面中的 Host 雖然以 www 呈現, 但是我們在這裡的實際操作是讓 demo.code4future.org 指向 wp-topuniversity.rhcloud.com.

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy5.png" width="800" /&gt;

在上述 Godaddy 帳號中, 隸屬於我們所購買網址的 DNS Manage, 新增一筆 DNS CNAME 別名設定並存檔後, 假如我們這時以瀏覽器連結 http://demo.code4future.org, 就會出現下列錯誤的畫面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy6.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy7.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy8.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy9.png" width="800" /&gt;

目前以 demo.code4future.org 新的網址連結會產生錯誤, 主要原因在於, 雖然 Godaddy 中已經將 demo.code4future.org 以 DNS 別名設定指向 wp-topuniversity.rhcloud.com, 但是 Wordpress 中的網址仍然設為 wp-topuniversity.rhcloud.com. 

因此接下來就要登入 wp-topuniversity.rhcloud.com 網站, 將應用程式的網址改為 demo.code4future.org.

Step 2:

登入 Wordpress 網站, 請注意這個時候要利用第 1 篇所完成的 Wordpress 網址登入, 在這裡網站符號名稱為 wp-topuniversity.rhcloud.com, 登入前畫面如下:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy10.png" width="800" /&gt;

登入 Wordpress 網站後的畫面如下:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy11.png" width="800" /&gt;

接下來我們要進入 Settings-&gt;General 設定中, 點選畫面如下:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy12.png" width="800" /&gt;

進入 General settings 後畫面如下, 這時可以看到 Wordpress 網誌所使用的網址為 wp-topuniversity.rhcloud.com.

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy13.png" width="800" /&gt;

下圖則顯示已經將原先使用的 wp-topuniversity.rhcloud.com 改為第 1 步 DNS 設定中所使用的 demo.code4future.org：

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy14.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy15.png" width="800" /&gt;

完成 Godaddy 的 DNS 設定, 並且將 Wordpress 原先使用的網址改為 demo.code4future.org, 整個網站仍無法正常運作, 因為 OpenShift 端仍然使用 wp-topuniversity.rhcloud.com 當作平台網站的符號名稱.

因此接著登入 OpenShift, 準備進行第 3 步網站名稱的修改.

Step 3:

登入 OpenShift 後進入應用程式, 畫面如下:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy16.png" width="800" /&gt;

進入要修改網址的應用程式連結後, 畫面如下, 這時點選 change, 表示要更改網站符號名稱:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy17.png" width="800" /&gt;

按下 change 按鈕後, 在 Domain name 欄位中填入新網站名稱, 在此一案例中, 新網站名稱為 demo.code4future.org:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy18.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy19.png" width="800" /&gt;

儲存新網站設定名稱後, 回到 OpenShift 應用程式設定畫面後, 網站名稱已經變成 demo.code4future.org 了.

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy20.png" width="800" /&gt;

假如上述的設定順利完成, 那麼恭喜您, 如下圖所示, 你的 Wordpress 網誌已經成功改用您所選定的網址, 在這個範例中 ,就是 &lt;a href="http://demo.code4future.org"&gt;http://demo.code4future.org&lt;/a&gt;.

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/godaddy/c4f_godaddy21.jpg" width="800" /&gt;

總結

我們在第 1 篇說明中, 已經完成在 OpenShift 平台上建立一個 Wordpress 網站, 但是使用的是 rhcloud.com 的網址, 雖然 namespace 與應用程式名稱都可以自選, 但是我們可以利用上述的3個步驟設定, 以我們自己從 Godaddy 所購買的網域中的一個對應網址來跑 Wordpress 網誌, 因此我們總共進行了 3 個不同系統中的設定.

第 1 項設定是 Godaddy 帳號中的設定, 建立一個別名 (CNAME), 將 demo.code4future.org 指向 wp-topuniversity.rhcloud.com.

第 2 項設定則是 Wordpress 系統本身, 必須登入後在 Settings-&gt;General 中, 將運行 Wordpress 的網址, 從 wp-topuniversity.rhcloud.com 改為 demo.code4future.org, 總共有兩個欄位必須更改.

而第 3 項設定則是 OpenShift 平台中應用程式所採用的 domain name alias 修改, 將原先使用的 wp-topuniversity.rhcloud.com 改為 demo.code4future.org.

完成上述一連串設定後, 終於可以用自己選定的網址來執行 Wordpress 網誌了.</t>
<t tx="amd.20160717163525.1"></t>
<t tx="amd.20160717183001.1">@language md
Title: 我們如何建立這個網站 (三)
Category: 社會人士
Tags: Godaddy, OpenShift, Wordpress, 專題研究, 網誌架構
Author: code4future
@others
在前兩篇文章中, 我們利用自己在 Godaddy 所購買的網域名稱, 配合 OpenShift 雲端平台, 建立了一個 &lt;a href="http://demo.code4future.org"&gt;http://demo.code4future.org&lt;/a&gt; 網站. 在這篇文章中, 我們將要加入 disqus 留言系統功能, 並且要利用 reCAPTCHA 來保護我們的帳號登錄流程, 減少被廣告商恣意利用程式方法入侵網誌系統.

&lt;!-- PELICAN_END_SUMMARY --&gt;



Step 1: 

登入 Wordpress 網站.

由於 disqus 與 reCAPTCHA 的導入採用 Wordpress plugin 方法, 因此要導入的第1步就是登入我們已經建好的 Wordpress 網站:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus1.png" width="800" /&gt;

登入後, 選擇 Plugins-&gt;Add New 表示要新增 Plugins:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus2.png" width="800" /&gt;

首先利用 Disqus Comment System 作為關鍵字, 找出 Plugin, 然後安裝後 activate: 

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus3.png" width="800" /&gt;

接著用 WordPress ReCaptcha Integration 作為關鍵字, 找出 Plugin, 也是安裝之後 activate:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus4.png" width="800" /&gt;

接著設定 ReCaptcha plugin, 先點進 ReCaptcha, 然後在另外一個頁面, 登入 Gmail 帳號, 因為需要登入電子郵箱後取得設定用的 Site key 與 secret key, 以下為設定過程中的參考畫面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus5.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus6.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus7.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus8.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus9.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus10.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus11.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus12.png" width="800" /&gt;

接著設定 Disqus 留言系統, 先從 Plugins 頁面中的 Disqus Comment System 選擇其下的 Configure:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus13.png" width="800" /&gt;

然後點選 Upgrade, 以配合隨後要加入的 Disqus 留言系統:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus14.png" width="800" /&gt;

在 Install Disqus Comments 過程中, 需要註冊一個 Disqus 帳號, 若已經有 Disqus 帳號, 則在下圖中輸入 Disqus 帳號與密碼, 若尚未建立 Disqus 帳號, 則利用 dont have a Disqus Profile yet 申請:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus15.png" width="800" /&gt;

如下圖所示, 可以用 Gmail 帳號登入, 以便串聯隨後要申請的 Disqus 帳號:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus16.png" width="800" /&gt;

接著利用 Gmail 郵箱作為帳號, 輸入要作為 Disqus 帳號的密碼後, 就可以完成 Disqus 帳號建立:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus17.png" width="800" /&gt;

Disqus 帳號建立後登入, 可以利用滑鼠右鍵從 Disqus Home 頁面最右方的設定圖像, 帶出 Add Disqus to site 頁面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus18.png" width="800" /&gt;

接著將 Add Disqus to site 頁面拉到最底下的左方, 點選 Get Started:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus19.png" width="800" /&gt;

接著註冊一個留言專用的 site name,  這裡使用了 demo_c4f_org 作為 site name, Wordpress 將會使用這個名稱當作留言系統的對應名稱:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus20.png" width="800" /&gt;

接著按下同意使用條款後, 就可以回到 Wordpress 測試設定是否成功:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus21.png" width="800" /&gt;

一旦使用者在 Disqus 註冊了留言系統後, 登入 Disqus 後, 就可以從 Home 頁面的 Admin 連結, 進入各 site name 的管理頁面:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus22.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus23.png" width="800" /&gt;

接續前面 Wordpress Disqus Comment System plugin 的設定, 只要登入 Disqus, 就會出現下列畫面, 可以選擇要附加的留言 site name, 下圖只有一個 demo_c4f_org 可以選擇:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus24.png" width="800" /&gt;

按下 Next, 就會出現 Disqua 留言系統已經設定完成:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus_25.png" width="800" /&gt;

另外, 如下圖所示, 在啟用 Disqus 之前, 必須用登錄的 Gmail 進行帳號驗證的動作, 才能開啟 Disqus 留言功能:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus26.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus27.png" width="800" /&gt;

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus28.png" width="800" /&gt;

最後, 我們要修改 Awesomeone theme 主題中 slider 的標題, 說明文字與對應連結, 如下圖所示, 先進入 Appearance-&gt;Customize:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus29.png" width="800" /&gt;

如下圖, 往下拉, 選擇 slider settings:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus30.png" width="800" /&gt;

如下圖, 左側就是 Awesomeone theme 目前三張 sliders 的設定欄位, 可以依照實際需求修改:

&lt;img src="http://code4futuretw.github.io/blogsite_data/files/disqus/c4f_disqus31.png" width="800" /&gt;

結語

在這篇文章中, 我們承接前面兩篇文章建立 Wordpress 網誌, 加入兩個 plugins, 分別用來提升網誌留言系統的效能, 並且利用 reCAPTCHA plugin 來防止駭客利用程式方法擾亂我們所建立的網站, 最後還展示如何修改 Awesomeone theme 主題中的 Sliders  內容.
</t>
<t tx="amd.20160718233536.1">@language md
Title: 我們認知中的所謂工業 4.0
Category: 社會人士
Tags: 專題研究, 工業4.0
Author: code4future
@others
當德國在幾年前喊出所謂的工業 4.0, 台灣似乎也跟著動了起來, 許多團隊都希望能夠與這個"名詞"沾上邊, 深怕沒有跟著喊, 好像就會很落伍一樣!?

&lt;!-- PELICAN_END_SUMMARY --&gt;

在這裡, 就讓我們來談談自己認知中的所謂工業 4.0.

看看我們的周遭, 現在到底是個怎麼樣的環境?

您前面的這台桌上型電腦, CPU 型號是 Intel Core i7-5960X, 運算能力超過 300 GFlops, 大約等同 1996 年運算能力最快的超級電腦. 而您的網路對外連線速度為 10 Gbit/s, 每秒可以傳送大約 1 GByte 的資料, 而您所使用的 IPV6 網路協定, 其定址總數量, 可以讓整個地球所有物體的每一個原子都有一個以上的 IPV6 位址.

光是從一台桌上型電腦的高速運算能力, 加上高速網路連線, 再加上數量幾乎難以估算的 IPV6 網路位址, 再回頭來看看我們日常生活, 是否會覺得這三種遠遠超出我們目前需求或配置的利器, 其實大多數時間都閒置在一旁.

所以我們認知中的所謂工業 4.0, 其實只是一個概念, 就是要告訴您說, 假如您能夠充份運用上述的這三項數位利器, 再加上已經發展到奈米等級的各種感測器, 配上無所不在的機器深度學習或人工智慧, 那麼在萬事萬物充份連線, 積極將每一個環節都最佳化, 那樣的未來, 就是工業 4.0.

但是, 隨著 Windows 10 想要搭著這一波全球電子裝置全面整合的架構, 將原本屬於個人操控的電腦操作系統, 轉型為全時連線的網路服務來看, 人類生活全面進入所謂的工業 4.0 並非全然都是美好或美麗的新世界, 也可能是一個難以忍受的新 1984 世代, 人被機器綁架, 當然機器背後是這些貪婪無度, 想要藉著高度發展與整合的科技來操控用戶, 這絕對不是處於弱勢且毫無感知後果的用戶所樂見的.

因此 ,面對正在發展中的工業 4.0 概念, 未來將逐步從工廠擴散到每一個人的生活圈, 我們身為現代人, 無論從事那一種行業, 都必須對於這些數位運算技術有一定程度的了解與應用能力, 否則完全依賴所謂的高科技公司或團隊的打理下的軟硬體應用, 就好像買了一台網路無法斷線, 即時錄音錄影軟硬體無法關閉, 甚至永遠無法關機的電腦回家一樣可怕.

學習這些數位運算技術的底線, 古聖先賢早就說過了: 役物而不役於物!</t>
<t tx="amd.20160721203641.1">@language md
Title: 我們如何面對網站被駭
Category: 社會人士
Tags: 專題研究, 網站, 駭客
Author: code4future
@others
是的, 我們週邊的幾個網站被駭了, 當用戶連結到這些網站, Google 趕忙提出警告, 讓用戶無法擷取網站的內容.

&lt;!-- PELICAN_END_SUMMARY --&gt;

這幾個網站是採用 Wordpress 建立的, 使用 MySQL 資料庫, 架構在 OpenShift 雲端平台之上, 被駭入的時間點大約在這個月份中旬, 儘管如此, 我們並沒有丟失任何資料, 因為我們早就在等著這一天.

OpenShift 雲端平台的使用或許簡單, 但是背後所運用的架構及流程相對複雜, 作為免費的 OpenShift 平台用戶, 我們沒有任何抱怨, 只在第1時間利用 Git 將平台上的資料 clone 到近端來分析, 試著想要找出那一個環節出了問題.

而在此之前, 我們的每一個網站資料內容都有動態與靜態等兩種格式, 大部分的內容都儘量保持同步, 而靜態的內容採用 Github Pages 與 Pelican 建置, 而且利用 Leo Editor 以程式方法加以管理, 在 Github 的倉儲下, 每一次提交推送版本都在遠端與近端各存一份, 而且還利用 git remote add, 放了另外一份同步的倉儲在 Bitbucket, 因此資料幾乎沒有丟失的可能.

好, 有了這樣萬全的準備, 我們還是想要知道, 駭客是如何攻陷這幾個網站的?

git clone OpenShift 平台網站的資料到近端簡單分析一下, 問題出在 .openshift 中的啟動碼, 而且只有大約一年之前所建立的 application 受到影響, 過去幾個月建立的應用程式則沒有受到影響.

有了這樣的發現, 利用 git rm -rf *, 在版本資料中刪除所有的資料, 只留下 .git, 然後用最新的 OpenShift 平台上的 Wordpress 倉儲檔案, 重新提交推送到 OpenShift, 就這樣蓋掉被駭客入侵的舊檔案, 應該算是暫時解決了網站被駭的問題.

然後呢?就是等著下一次網站再次被駭!再救, 再設法解決問題, 報告完畢.</t>
<t tx="amd.20160721205749.1"></t>
<t tx="amd.20160721205754.1"></t>
<t tx="amd.20160721205758.1"></t>
<t tx="amd.20160724161400.1">@language md
Title: 我們如何處理舊電腦?
Category: 社會人士
Tags: 專題研究, 電腦, 操作系統, 驅動程式
Author: code4future
@others
假如您在 2012 年入手了幾台 HP TouchSmart 320-1038tw 桌上型電腦, 當時在 Windows 7 的操作系統下, 觸控螢幕可能發揮不了太多功能, 即便您已經配合保固期內的自動升級成 Windows 8.1, 觸控螢幕卻因為 &lt;a href="http://support.hp.com/us-en/drivers/selfservice/hp-touchsmart-320-1000-desktop-pc-series/5146287/model/5149296#Z7_3054ICK0K8UDA0AQC11TA930O2"&gt;原廠該型的驅動程式支援網站&lt;/a&gt;中, 已經找不到支援 Windows 8 以上的觸控螢幕的驅動程式, 加上在台灣 2016 年 7 月 29 日之前免費升級成 Windows 10 操作系統的檢查程式不斷告訴您, HP TouchSmart 320-1038tw 硬體無法升級成 Windows 10, 或許您已經選擇相信微軟, 決定要購買新的電腦了?

&lt;!-- PELICAN_END_SUMMARY --&gt;

2012 年購買的電腦硬體, 在 4 年的期間微軟一口氣從 Windows 7 轉進到目前的 Windows 10, 當然 &lt;a href="http://h20564.www2.hp.com/hpsc/doc/public/display?docId=c03085254"&gt;HP TouchSmart 320-1038tw&lt;/a&gt; 使用的 AMD E2 3200 處理器, 並不是什麼高階機種, 但是應該可以相容 Windows 10 操作系統, 只不過原先 HP TouchSmart 320-1038tw 只內建 2GB 記憶體, 而且 200 pin 的 DDR3 1333-1600 的記憶體已經愈來愈少, 何況 HP TouchSmart 320-1038tw 只有兩個記憶體插槽, 且最高每條只支援 4GB, 因此最佳的情況是準備兩條 4GB 的記憶體, 然後從 Windows 8.1 升級到 Windows 10, 可是, 觸控螢幕的驅動程式到底在哪裡?

前面提過 &lt;a href="http://support.hp.com/us-en/drivers/selfservice/hp-touchsmart-320-1000-desktop-pc-series/5146287/model/5149296#Z7_3054ICK0K8UDA0AQC11TA930O2"&gt;原廠該型的驅動程式支援網站&lt;/a&gt;中, 已經找不到支援 Windows 8 以上的觸控螢幕的驅動程式, 因此想要在 Windows 8.1 以上讓觸控螢幕發揮作用, 只能從觸控螢幕的型號下手.

仔細閱讀硬體規格後, 發現 HP TouchSmart 320-1038tw 所使用的觸控螢幕為 NextWindow Voltron Touch Screen 6214, 而能夠支援 Windows 8 的驅動程式位於 &lt;a href="http://h20564.www2.hp.com/hpsc/swd/public/detail?swItemId=vc_115774_1"&gt;http://h20564.www2.hp.com/hpsc/swd/public/detail?swItemId=vc_115774_1&lt;/a&gt;, 而 Windows 10 的驅動程式則位於 &lt;a href="http://www.driverscape.com/download/nextwindow-voltron-touch-screen"&gt;http://www.driverscape.com/download/nextwindow-voltron-touch-screen&lt;/a&gt;.

最後 HP TouchSmart 320-1038tw 假如只有 2GB 的記憶體, 並不建議升級到 Windows 10, 而是停留在 Windows 8.1, 然後只應付輕度使用, 例如用來聽聽音樂上上網, 假如真要升級到 Windows 10, 則建議將另外一台 HP TouchSmart 320-1038tw 的 2GB 記憶體拔過來用, 這下子, 希望這台外觀漂亮, Beats 音響表現還不錯的 20 吋觸控螢幕電腦, 還能夠多撐幾年.</t>
<t tx="leo.20151212173315.1"></t>
<t tx="leo.20151212173315.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20151212173315.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20151212173658.1">@language python
import os
#os.system("pelican content -o ./ -s publishconf.py -t theme/pelican-bootstrap3")
os.system("pelican content -o blog -s publishconf.py")
g.es("admin pelican 執行完畢")

</t>
<t tx="leo.20151213085727.1">@language python
import os
#os.system("pelican content -o output -s local_publishconf.py -t theme/pelican-bootstrap3")
os.system("pelican content -o blog -s local_publishconf.py")
g.es("admin pelican 近端執行完畢")


</t>
<t tx="leo.20151213173811.1"></t>
<t tx="leo.20151213173830.1"></t>
<t tx="leo.20151213230723.1"></t>
<t tx="leo.20151213230729.1">利用

&lt;!-- PELICAN_END_SUMMARY --&gt;

來界定 Summary 摘要內容

前提, 必須設定 

PLUGIN_PATHS = ['plugin']

與

PLUGINS = ['liquid_tags.notebook', 'summary']

並且從 https://github.com/getpelican/pelican-plugins

取得 summary plugin</t>
<t tx="leo.20151213230957.1"># 設定網誌以 md 檔案建立的 file system date 為準, 無需自行設定

DEFAULT_DATE = 'fs'</t>
</tnodes>
</leo_file>
