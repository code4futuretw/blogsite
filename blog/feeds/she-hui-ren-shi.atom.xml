<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Code4future</title><link href="http://blog.code4future.org/blog/" rel="alternate"></link><link href="http://blog.code4future.org/blog/feeds/she-hui-ren-shi.atom.xml" rel="self"></link><id>http://blog.code4future.org/blog/</id><updated>2016-07-12T23:15:27+08:00</updated><entry><title>我們如何利用程式方法解決自己的問題</title><link href="http://blog.code4future.org/blog/wo-men-ru-he-li-yong-cheng-shi-fang-fa-jie-jue-zi-ji-de-wen-ti.html" rel="alternate"></link><updated>2016-07-12T23:15:27+08:00</updated><author><name>code4future</name></author><id>tag:blog.code4future.org,2016-07-12:blog/wo-men-ru-he-li-yong-cheng-shi-fang-fa-jie-jue-zi-ji-de-wen-ti.html</id><summary type="html">&lt;p&gt;在這篇文章中, 我們介紹如何利用 Python3 程式的特性與工具來解決我們在網誌發表上所面臨的問題.&lt;/p&gt;


&lt;p&gt;一般在網路上發表網誌有動態與靜態等兩種選擇, 所謂動態網誌, 就是網誌系統直接在全球資訊網路上提供編修文章與管理的功能, 使用者可以直接利用全球資訊網瀏覽器, 以帳號登入網誌管理系統, 依照使用者權限管理內容.&lt;/p&gt;
&lt;p&gt;動態網誌的好處就是即時而且靈活, 但是壞處則是資料的傳送必須透過全球資訊網程式處理後, 轉為 html 資料格式, 因此使用者擷取網誌內容的反應速度, 較事先已經轉成 html 的靜態網誌慢, 而另外一個壞處則是, 動態網誌將管理系統直接放在全球資訊網伺服器上, 儘管可以透過各種安全防護機制加以保護, 但是仍然帶有被駭客入侵修改內容的風險.&lt;/p&gt;
&lt;p&gt;至於靜態網誌則是使用者利用各種方式編修網誌內容後, 將已經轉成 html 格式的內容送到全球資訊網伺服器, 而在 WWW 伺服器中並沒有提供任何用來管理網誌內容的程式, 因此好處是被擷取的反應速度較動態網誌快, 並且少掉被駭客入侵網誌管理系統的機會, 只有駭客攻破提供全球資訊網伺服器的雲端架構, 靜態網誌內容才可能受到破壞. 而靜態網誌的缺點則是無法像動態網誌一樣, 即時直接讓使用者在瀏覽器中編修文章內容.&lt;/p&gt;
&lt;p&gt;了解動態網誌與靜態網誌的特性後, 一般使用者在建立網誌的過程中, 若希望能夠透過即時協同的方式, 多人共同管理網誌文章, 並且能夠有效保存各階段性的網誌文章內容. 大多採用動態網誌系統. 但是若想要利用類似 Github Pages 的架構, 利用分散式資料管理系統, 例如 GIT, 來管理每一個版本的內容, 則靜態網將會是比動態網誌更適合.&lt;/p&gt;
&lt;p&gt;以 Code4Future 來說, 我們想要同時擁有上述動態與靜態網誌的優點, 但是又必須儘量讓兩個不同系統的內容能夠同步, 於是我們想出利用程式方法來媒合兩種風格迥異的網誌系統.&lt;/p&gt;
&lt;p&gt;基本的作法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;我們其實是同時建立一個 Wordpress 靜態網誌系統與靜態的 Python3 Pelican 網誌系統.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wordpress 網誌系統的用法與一般動態網誌的管理模式相同, 可以讓負責協同的人員建立帳號, 依照帳號權限管理網誌內容.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python3 Pelican 的靜態網誌建立, 也採用一般靜態網誌的建立與上傳方法, 只是我們選擇利用 Github Pages 來伺服我們的靜態網誌.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;結合 Wordpress 與 Pelican 網誌內容的基本技術植基於 &lt;a href="https://zh.wikipedia.org/wiki/XML-RPC"&gt;XML-RPC&lt;/a&gt; 協定, 因為 Wordpress 是採用 PHP 程式語言編寫, 而 Pelican 則是採用 Python 程式語言, 假如沒有中繼的 XML-RPC 協定來轉換兩者的資料內容, 使用者就必須從 Wordpress 儲存資料的資料庫系統下手.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外一個重要的程式架構則是, 我們選擇以 &lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 來管理這個資料互動的程式流程.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由於從 Pelican 靜態網誌系統將資料轉進或轉出 Wordpress 時, 需要擁有管理資料的帳號密碼, 這時我們利用存在使用者電腦特定位置的帳號密碼讀取, 來登入 Wordpress 系統.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假如原始網誌內容先在 Wordpress 建立, 則位於 Leo Editor 專案中的 Pelican 靜態網誌管理系統可以利用 get-from-wp 按鈕將資料取回.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假如原始網誌內容先在 Pelican 建立, 則可以利用 Leo Editor 的 new-to-wp 按鈕, 將靜態網誌內容推向 Wordpress.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假如 Wordpress 網誌內容更動, 則 Pelican 可以再利用 get-from-wp 按鈕取回最新的資料.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假如位於 Pelican 管理系統中的網誌內容更動, 則可以利用 Leo Editor 的 edit-to-wp 按鈕將更新資料推向 Wordpress.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下為實際的 Leo Editor 按鈕程式碼:&lt;/p&gt;
&lt;p&gt;new-to-wp-button&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &amp;lt;!-more-&amp;gt;
    content = content.replace('&amp;lt;!-- PELICAN_END_SUMMARY --&amp;gt;', '&amp;lt;!--more--&amp;gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content

os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/home/amd/Desktop/www-code4future.txt"
wordpress = "www.code4future.org"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"

status_draft = 0
status_published = 1

server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
# 先用 : 斷開標投頭的 Tags:, 然後再透過逗點隔開, 將標註轉為數列資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

post_id = server.metaWeblog.newPost(wp_blogid, wp_username, wp_password, data, status_published)
# 利用最後的 child 節點來儲存 post_id
to_save_post_id = p.insertAsLastChild()   
# 改為內文為空的節點, id 直接標在 head 標題 
to_save_post_id.b = ""
to_save_post_id.h = post_id
# 因為新增節點, commander 必須 redraw
c.redraw() 

g.es("post_id 為", post_id)
g.es("已經送出資料!")
&lt;/pre&gt;

&lt;p&gt;edit-to-wp-button&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#coding: utf-8
import xmlrpc.client
import datetime
import os

def get_cat_tag_content(data):
    # 請注意, 因為 data 來自 .md 的 body pan 內容, 第1行為 @language python
    # 用跳行符號分割
    data_list = data.split("\n")
    #第2行為 title
    title= data_list[1]
    #第3行為 category
    category = data_list[2]
    #第4行為 tags
    tags = data_list[3]
    # 有多項資料的 content 型別為數列
    # 再將第7行之後的資料數列串回成以跳行隔開的資料
    content = "\n".join(data_list[6:])
    # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Wordpress 的 &amp;lt;!-more-&amp;gt;
    content = content.replace('&amp;lt;!-- PELICAN_END_SUMMARY --&amp;gt;', '&amp;lt;!--more--&amp;gt;')
    # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式
    content = content.replace('~~~python', '[code lang="python"]')
    content = content.replace('~~~', '[/code]')
    return title, category, tags, content

os.environ['TZ'] = 'Asia/Taipei'

#################################
filepath = "/home/amd/Desktop/www-code4future.txt"
wordpress = "www.code4future.org"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################
wp_blogid = "0"

status_draft = 0
status_published = 1

server = xmlrpc.client.ServerProxy(wp_url)

# 從目前所在節點的 body pan 中取出類別, tags 以及文章內容
title_str, category_str, tags_str, content = get_cat_tag_content(p.b)
# title 是一個單獨的字串
title = title_str.split(":")[1]
# 指定時間出版
'''
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime("2013-01-01 00:00",
"%Y-%m-%d %H:%M"))
'''
# 以現在時間出版, 考慮與 Server 時間差八個小時 (480 分鐘), 因此要在 8 個小時前發表
date_created = xmlrpc.client.DateTime(datetime.datetime.strptime((datetime.datetime.now()- \
datetime.timedelta(minutes=480)).strftime('%Y-%m-%d %H:%M'),"%Y-%m-%d %H:%M"))
categories = [category_str.split(":")[1]]
# 請注意, 因為 tags 用逗點隔開, 因此必須透過 split() 再分開成為 list 資料
tags = tags_str.split(":")[1].split(",")
data = {'title': title, 'description': content, 'dateCreated': date_created, 'categories': categories, 'mt_keywords': tags}

# 設法取得原 post 的 id
origin_post = p.getLastChild()
# 直接從標題取得 post 的 id 號碼
post_id = origin_post.h
status = server.metaWeblog.editPost(post_id, wp_username, wp_password, data, status_published)

if status:
    g.es("資料已經更新!")
else:
    g.es("有問題, 資料沒有更新!")
&lt;/pre&gt;

&lt;p&gt;get-from-wp button&lt;/p&gt;
&lt;pre class="brush: python"&gt;
#coding: utf-8
import xmlrpc.client
# 導入 html 模組, 使用 html.unescape 轉換 html 特殊符號
import html

#################################
filepath = "/home/amd/Desktop/www-code4future.txt"
wordpress = "www.code4future.org"
fo = open(filepath, "r+")
data = []
for line in fo.readlines():
    data.append(line)
fo.close()

# 從網誌節點的 parent().h 取得 wp_url
# 從網誌節點的 parent().b 取得帳號與密碼對應的文字檔案路徑
wp_url = "https://"+wordpress+"/xmlrpc.php"
wp_username = data[0]
wp_password = data[1]
#################################

server = xmlrpc.client.ServerProxy(wp_url)

# 設法透過上述網誌網址, 帳號與密碼, 以及文章 id, 取回 categories, tags, 文章標題, 文章內容等資

# 從最後的 child 節點來取 post_id
origin_post = p.getLastChild()
post_id = origin_post.h
# 取回與 post_id 對應的網誌文章內容
blog_content = server.metaWeblog.getPost(post_id, wp_username, wp_password)
title = blog_content["title"]
# 這裡要利用 html.unescape 轉回特殊符號
description = html.unescape(blog_content["description"])
mt_text_more = html.unescape(blog_content["mt_text_more"])
if mt_text_more != "":
    post_content = description + "\n&amp;lt;!--more--&amp;gt;\n"+mt_text_more
else:
    post_content = description
# 所取回的 categories 為 list
categories = blog_content["categories"]
# 所取回的 tags 為以逗點隔開的字串
mt_keywords = blog_content["mt_keywords"]
# 取回文章作者
author = blog_content["wp_author_display_name"]
p.h = title
categories_str = ""
for category in categories:
    # 假如不是最後一個
    if category != categories[len(categories)-1]:
        categories_str += category + ", "
    else:
        # 這是最後一個
        categories_str += category
line1 = "@language md\n"
line2 = "Title: " +title + "\n"
line3 = "Category: " + categories_str + "\n"
line4 = "Tags: " + mt_keywords + "\n"
line5 = "Author: " + author + "\n@others\n"
post_content = post_content.replace('&amp;lt;!--more--&amp;gt;', '\n&amp;lt;!-- PELICAN_END_SUMMARY --&amp;gt;\n')
post_content = post_content.replace('[code lang="python"]', '~~~python')
post_content = post_content.replace('[/code]', '~~~')
p.b = line1 + line2 + line3 + line4 + line5 + post_content + "\n"
# 因為節點資料更新, commander 必須 redraw
c.redraw() 
g.es("資料已經取回")
&lt;/pre&gt;</summary><category term="專題研究"></category><category term="網誌架構"></category></entry><entry><title>有關社會人士學習電腦</title><link href="http://blog.code4future.org/blog/you-guan-she-hui-ren-shi-xue-xi-dian-nao.html" rel="alternate"></link><updated>2016-03-20T08:13:42+08:00</updated><author><name>code4future</name></author><id>tag:blog.code4future.org,2016-03-20:blog/you-guan-she-hui-ren-shi-xue-xi-dian-nao.html</id><summary type="html">&lt;p&gt;社會人士學習電腦的課題很廣, 我們只能提供較為基本的電腦使用功能與觀念的導引, 例如, 有關 Windows 與 Ubuntu 操作系統的取捨, 如何運用網路與網站來提升工作效率等.&lt;/p&gt;


&lt;p&gt;Code4Future 將與社會人士學習電腦的主題劃分為:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;電腦基本軟硬體層次, 桌上型、筆記型與卡片型電腦的取捨, Windows 或 Ubuntu 操作系統?&lt;/li&gt;
&lt;li&gt;基本的本地端網路協定、設定與應用&lt;/li&gt;
&lt;li&gt;區域網路上的全球資訊網伺服器與雲端全球資訊網伺服器的應用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;全球資訊網上, 免費學習電腦編程的網站:&lt;/p&gt;
&lt;p&gt;CodeCademy：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.codecademy.com/"&gt;https://www.codecademy.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;FreeCodeCamp:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.freecodecamp.com/"&gt;https://www.freecodecamp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Udemy:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.udemy.com/"&gt;https://www.udemy.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Khanacademy:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.khanacademy.org/computing/computer-programming"&gt;https://www.khanacademy.org/computing/computer-programming&lt;/a&gt;&lt;/p&gt;</summary><category term="電腦基本功能"></category></entry><entry><title>全雲端電腦輔助機械設計 3D 套件</title><link href="http://blog.code4future.org/blog/quan-yun-duan-dian-nao-fu-zhu-ji-jie-she-ji-3d-tao-jian.html" rel="alternate"></link><updated>2016-03-20T01:13:14+08:00</updated><author><name>code4future</name></author><id>tag:blog.code4future.org,2016-03-20:blog/quan-yun-duan-dian-nao-fu-zhu-ji-jie-she-ji-3d-tao-jian.html</id><summary type="html">&lt;p&gt;一般人對於所謂的電腦輔助機械設計繪圖套件, 可能都還停留在單機 ,必須安裝, 必須經過軟硬體授權認証才能啟動的單機應用程式. 自從 2015 年3月份開始, 一群曾經在 1993 協助打造全世界第一套個人電腦操作系統上的 MCAD (Mechanical Computer Aided Design) 團隊, 推出了 OnShape, 從此您又多了一個選擇, 可以在各種電腦裝置 (包括手機與平板電腦) 上設計繪製 3D 的零組件, 不僅能與多人進行即時協同設計, 並且可以從擁有 500MB 到 5GB 的免費帳號開始入門.&lt;/p&gt;


&lt;p&gt;今天起, 請您暫時放下其他類似的 MCAD 套件, 開始關注: &lt;a href="https://www.onshape.com/"&gt;https://www.onshape.com/&lt;/a&gt;.&lt;/p&gt;
&lt;video controls autoplay="autoplay" width="800" height="600"&gt;
  &lt;source src="http://code4futuretw.github.io/blogsite_data/files/grab-windows700kb.mp4"&gt;
  Your browser does not support the video tag.
&lt;/video&gt;

&lt;video controls autoplay="autoplay" width="800" height="600"&gt;
  &lt;source src="http://code4futuretw.github.io/blogsite_data/files/ipad-air-720p_700kb.mp4"&gt;
  Your browser does not support the video tag.
&lt;/video&gt;

&lt;video controls autoplay="autoplay" width="800" height="600"&gt;
  &lt;source src="http://code4futuretw.github.io/blogsite_data/files/laptop-720p-apple700kb.mp4"&gt;
  Your browser does not support the video tag.
&lt;/video&gt;</summary><category term="MCAD"></category><category term="CAD"></category></entry><entry><title>如何架構一個動靜皆宜的網誌系統</title><link href="http://blog.code4future.org/blog/ru-he-jia-gou-yi-ge-dong-jing-jie-yi-de-wang-zhi-xi-tong.html" rel="alternate"></link><updated>2016-03-19T13:29:17+08:00</updated><author><name>code4future</name></author><id>tag:blog.code4future.org,2016-03-19:blog/ru-he-jia-gou-yi-ge-dong-jing-jie-yi-de-wang-zhi-xi-tong.html</id><summary type="html">&lt;p&gt;全球資訊網上有兩種基本的 Blog 架構, 動態的網誌以 &lt;a href="https://wordpress.com/"&gt;Wordpress&lt;/a&gt; 為代表, 而靜態的網誌則以 &lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt; 為例.&lt;/p&gt;


&lt;p&gt;這一篇文章的目的, 在介紹 Code4Future 團隊如何利用 PHP、Python3, 在 OpenShift 雲端平台與 Github 版次管理系統中, 用同 Leo Editor 的專案架構, 以同一份內容, 幾乎同步地更新到動態與靜態的兩個網站.&lt;/p&gt;
&lt;p&gt;首先, Code4Future 目前的動態網站為: &lt;a href="http://www.code4future.org"&gt;http://www.code4future.org&lt;/a&gt;, 而靜態網站則位於 &lt;a href="http://blog.code4future.org"&gt;http://blog.code4future.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;其中的動態網站採用 &lt;a href="https://www.openshift.com/"&gt;Openshift&lt;/a&gt; 雲端平台建構, 而靜態網頁則架構在 &lt;a href="https://pages.github.com/"&gt;Github Pages&lt;/a&gt; 上.&lt;/p&gt;
&lt;p&gt;從 &lt;a href="https://github.com/code4futuretw/blogsite"&gt;https://github.com/code4futuretw/blogsite&lt;/a&gt; 倉儲, 可以取得 &lt;a href="http://blog.code4future.org"&gt;http://blog.code4future.org&lt;/a&gt; 靜態網誌上的所有資料 ,包括 Pelican 設定與 Leo Editor 專案檔中的所有按鈕指令程式碼.&lt;/p&gt;
&lt;p&gt;首先來看, 如何在 OpenShift 建立一個 Wordpress 網誌:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;到 &lt;a href="https://www.openshift.com/"&gt;https://www.openshift.com/&lt;/a&gt; 申請一個帳號.&lt;/li&gt;
&lt;li&gt;收到 OpenShift 信件後, 按回電子郵箱的確認連結, 就可以開始在 OpenShift 雲端平台上建立應用程式.&lt;/li&gt;
&lt;li&gt;建立應用程式時, 選擇建立 Wordpress 類別的網誌, 並且選擇可用的網域名稱與應用程式名稱, 就可完成 Wordpress 起始設定.&lt;/li&gt;
&lt;li&gt;當建立 Wordpress 應用程式完成後, 使用者即可進行網誌的設定, 其中包括管理者帳號的建立與基本網誌設定.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至於 Github Pages 上的 &lt;a href="http://blog.code4future.org"&gt;http://blog.code4future.org&lt;/a&gt; 靜態網誌, 其架構則比較複雜, 一方面, 我們採用 &lt;a href="http://leoeditor.com/"&gt;Leo Editor&lt;/a&gt; 來管理所有資料. 當使用者從 &lt;a href="https://github.com/code4futuretw/blogsite"&gt;https://github.com/code4futuretw/blogsite&lt;/a&gt; 倉儲 git clone 資料到本地端之後, 必須依靠 Python3, PyQt, Pelican 與 Git 才能順利在本地端與 Github Page 分支端, 順利建立並管理這個靜態網誌系統.&lt;/p&gt;
&lt;p&gt;此外, 我們建構靜態網頁系統的目的, 是希望爾後在實體課堂中推廣 Code4Future 的各階段教材時, 可以無需上到廣域網路, 利用隨身硬碟與區域網路就能夠上課. 因此 Github 倉儲中的 Pelican 系統又分為本地端與雲端平台上的轉檔設定. 使用本靜態網頁時, 基本工作流程如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;從 &lt;a href="https://github.com/code4futuretw/blogsite"&gt;https://github.com/code4futuretw/blogsite&lt;/a&gt; 倉儲, git clone 資料到本地端.&lt;/li&gt;
&lt;li&gt;確定工作目錄中為倉儲的 gh-pages 分支內容.&lt;/li&gt;
&lt;li&gt;利用 Leo Editor 5.1 以後的版本, 開啟 users 目錄下的 c4f.leo, 就可以看到本站的所有資料.&lt;/li&gt;
&lt;li&gt;修改設定檔案內容.&lt;/li&gt;
&lt;li&gt;根據網誌 md 檔案中的格式, 編寫新網誌文章.&lt;/li&gt;
&lt;li&gt;先利用本地端所屬的 local-pelican 按鈕建立網誌文章.&lt;/li&gt;
&lt;li&gt;本地端內容查詢無誤後, 再用 gh-pages-pelican 按鈕, 產升即將送到雲端上的 Pelican 網誌內容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至於將 Pelican 中的 .md 檔案內容, 送到 Wordpress, 則配合 new-to-wp-pelican, edit-to-wp-pelican 與 get-from-wp-pelican 等3個按鈕指令.&lt;/p&gt;</summary><category term="導引"></category></entry></feed>